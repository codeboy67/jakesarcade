<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Endless Runner - Jake's Arcade</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
canvas { display: block; }
#backBtn {
    position: fixed; top: 12px; left: 12px; z-index: 100;
    color: #aaa; text-decoration: none; font-family: Arial, sans-serif;
    font-size: 14px; padding: 6px 12px; background: rgba(0,0,0,0.5);
    border-radius: 4px; transition: color 0.2s;
}
#backBtn:hover { color: #fff; }
</style>
</head>
<body>
<a id="backBtn" href="../../index.html">&larr; Back to Jake's Arcade</a>
<canvas id="gameCanvas"></canvas>
<script>
// ========== ENDLESS RUNNER ==========
(() => {
"use strict";

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const backBtn = document.getElementById('backBtn');

// ---- RESIZE ----
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ---- AUDIO ENGINE ----
let audioCtx = null;
function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, dur, type = 'square', vol = 0.15) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
}

function sfxJump() { playTone(400, 0.15, 'square', 0.12); setTimeout(() => playTone(600, 0.1, 'square', 0.1), 50); }
function sfxDoubleJump() { playTone(500, 0.1, 'square', 0.12); setTimeout(() => playTone(800, 0.15, 'square', 0.1), 60); }
function sfxSlide() { playTone(200, 0.15, 'sawtooth', 0.08); }
function sfxCoin() { playTone(880, 0.08, 'square', 0.1); setTimeout(() => playTone(1100, 0.1, 'square', 0.1), 60); }
function sfxPowerup() { playTone(440, 0.1, 'square', 0.12); setTimeout(() => playTone(660, 0.1, 'square', 0.1), 80); setTimeout(() => playTone(880, 0.15, 'square', 0.1), 160); }
function sfxHit() {
    if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.3;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    source.buffer = buffer;
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
    source.connect(gain);
    gain.connect(audioCtx.destination);
    source.start();
}
function sfxMilestone() {
    [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'square', 0.1), i * 100));
}

// ---- GAME STATE ----
const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2, PAUSED: 3 };
let state = STATE.MENU;
let stateBeforePause = STATE.PLAYING;
let distance = 0; // in pixels
let distanceMetres = 0;
let coins = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('endlessRunnerHigh')) || 0;
let gameSpeed = 6;
let baseSpeed = 6;
let speedMultiplier = 1;
let lastTime = 0;
let dt = 0;
let groundY = 0;
let currentTheme = 0; // 0=city, 1=forest, 2=desert, 3=snow
let themeTransition = 0;

// Power-up states
let hasShield = false;
let hasMagnet = false;
let magnetTimer = 0;
let scoreMultiplier = 1;
let multiplierTimer = 0;
let hasJetpack = false;
let jetpackTimer = 0;

// Particles
let particles = [];

// ---- THEMES ----
const themes = [
    { // City
        name: 'City',
        sky: ['#1a1a3e', '#2d2d6b', '#4a4a8a'],
        ground: '#444',
        groundLine: '#555',
        bgElements: 'city'
    },
    { // Forest
        name: 'Forest',
        sky: ['#0a2a1a', '#1a4a2a', '#2a6a3a'],
        ground: '#3a2a1a',
        groundLine: '#4a3a2a',
        bgElements: 'forest'
    },
    { // Desert
        name: 'Desert',
        sky: ['#4a2a0a', '#8a5a1a', '#ca8a2a'],
        ground: '#c4a44a',
        groundLine: '#d4b45a',
        bgElements: 'desert'
    },
    { // Snow
        name: 'Snow',
        sky: ['#2a3a5a', '#4a6a8a', '#8aaaba'],
        ground: '#ddeeff',
        groundLine: '#ccddef',
        bgElements: 'snow'
    }
];

// ---- PLAYER ----
const player = {
    x: 0, y: 0, w: 30, h: 50,
    vy: 0, onGround: true,
    jumping: false, jumpHeld: false, jumpTime: 0,
    sliding: false, slideTimer: 0,
    doubleJumped: false,
    animFrame: 0, animTimer: 0,
    alive: true,
    invincible: 0
};

const GRAVITY = 0.6;
const JUMP_FORCE = -13;
const JUMP_HOLD_FORCE = -0.5;
const MAX_JUMP_HOLD = 12;
const SLIDE_DURATION = 40;
const PLAYER_NORMAL_H = 50;
const PLAYER_SLIDE_H = 25;

// ---- INPUT ----
const keys = {};
let jumpPressed = false;
let slidePressed = false;
let lastJumpPress = 0;
let touchStartY = 0;
let touchStartX = 0;

window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'KeyS') {
        e.preventDefault();
    }
    // ESC: navigate to main menu from any non-menu state
    if (e.code === 'Escape' && state !== STATE.MENU) {
        window.location.href = '../../index.html';
        return;
    }
    // P: toggle pause during gameplay or while paused
    if (e.code === 'KeyP') {
        if (state === STATE.PLAYING || state === STATE.GAMEOVER) {
            stateBeforePause = state;
            state = STATE.PAUSED;
            return;
        } else if (state === STATE.PAUSED) {
            state = stateBeforePause;
            return;
        }
    }
    if (!keys[e.code]) {
        keys[e.code] = true;
        if (e.code === 'Space' || e.code === 'ArrowUp') jumpPressed = true;
        if (e.code === 'ArrowDown' || e.code === 'KeyS') slidePressed = true;
    }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch controls
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    ensureAudio();
    const t = e.touches[0];
    touchStartY = t.clientY;
    touchStartX = t.clientX;
    if (state === STATE.MENU) { startGame(); return; }
    if (state === STATE.GAMEOVER) { goToMenu(); return; }
    // Tap upper half = jump, lower half = slide
    if (t.clientY < canvas.height * 0.5) {
        jumpPressed = true;
    } else {
        slidePressed = true;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

canvas.addEventListener('touchend', e => {
    keys['Space'] = false;
    keys['ArrowDown'] = false;
}, { passive: false });

// Mouse for menus
canvas.addEventListener('click', e => {
    ensureAudio();
    handleClick(e.clientX, e.clientY);
});

function handleClick(mx, my) {
    if (state === STATE.MENU) {
        // Play button
        const bx = canvas.width / 2;
        const by = canvas.height / 2 + 40;
        if (mx > bx - 100 && mx < bx + 100 && my > by - 30 && my < by + 30) {
            startGame();
        }
    } else if (state === STATE.GAMEOVER) {
        // Play again
        const bx = canvas.width / 2;
        const by = canvas.height / 2 + 100;
        if (mx > bx - 100 && mx < bx + 100 && my > by - 30 && my < by + 30) {
            goToMenu();
        }
    } else if (state === STATE.PAUSED) {
        const bx = canvas.width / 2;
        // RESUME button
        const resumeY = canvas.height / 2 + 10;
        if (mx > bx - 130 && mx < bx + 130 && my > resumeY - 25 && my < resumeY + 25) {
            state = stateBeforePause;
        }
        // MAIN MENU button
        const menuY = canvas.height / 2 + 75;
        if (mx > bx - 130 && mx < bx + 130 && my > menuY - 25 && my < menuY + 25) {
            window.location.href = '../../index.html';
        }
    }
}

// ---- OBSTACLES, COINS, POWERUPS ----
let obstacles = [];
let coinList = [];
let powerups = [];
let gaps = [];
let bgObjects = []; // Background decoration
let bgLayers = [[], [], []]; // Parallax layers

let spawnTimer = 0;
let spawnInterval = 120;
let coinSpawnTimer = 0;
let powerupSpawnTimer = 0;

function resetGame() {
    distance = 0;
    distanceMetres = 0;
    coins = 0;
    score = 0;
    gameSpeed = 6;
    baseSpeed = 6;
    speedMultiplier = 1;
    currentTheme = 0;
    themeTransition = 0;
    hasShield = false;
    hasMagnet = false;
    magnetTimer = 0;
    scoreMultiplier = 1;
    multiplierTimer = 0;
    hasJetpack = false;
    jetpackTimer = 0;
    obstacles = [];
    coinList = [];
    powerups = [];
    gaps = [];
    particles = [];
    bgObjects = [];
    spawnTimer = 0;
    spawnInterval = 120;
    coinSpawnTimer = 0;
    powerupSpawnTimer = 0;

    groundY = canvas.height - 80;
    player.x = canvas.width * 0.15;
    player.y = groundY - PLAYER_NORMAL_H;
    player.vy = 0;
    player.onGround = true;
    player.jumping = false;
    player.jumpHeld = false;
    player.jumpTime = 0;
    player.sliding = false;
    player.slideTimer = 0;
    player.doubleJumped = false;
    player.h = PLAYER_NORMAL_H;
    player.alive = true;
    player.invincible = 0;
    player.animFrame = 0;
    player.animTimer = 0;

    initBgLayers();
}

function initBgLayers() {
    bgLayers = [[], [], []];
    for (let l = 0; l < 3; l++) {
        const count = 8 + l * 4;
        for (let i = 0; i < count; i++) {
            bgLayers[l].push({
                x: Math.random() * canvas.width * 2,
                type: Math.floor(Math.random() * 3),
                h: 30 + Math.random() * (60 + l * 40),
                w: 20 + Math.random() * (40 + l * 20)
            });
        }
    }
}

// ---- SPAWNING ----
function spawnObstacle() {
    const gY = groundY;
    const types = ['low', 'high', 'gap', 'spikeLow', 'spikeHigh'];
    if (distanceMetres > 200) types.push('pendulum');

    const type = types[Math.floor(Math.random() * types.length)];
    const x = canvas.width + 50;

    if (type === 'low') {
        const h = 30 + Math.random() * 25;
        obstacles.push({ type: 'low', x, y: gY - h, w: 30 + Math.random() * 20, h, color: getObstacleColor() });
    } else if (type === 'high') {
        obstacles.push({ type: 'high', x, y: gY - 100, w: 60 + Math.random() * 40, h: 25, color: getObstacleColor() });
    } else if (type === 'gap') {
        gaps.push({ x, w: 60 + Math.random() * 50 + Math.min(distanceMetres / 50, 40) });
    } else if (type === 'spikeLow') {
        obstacles.push({ type: 'spikeLow', x, y: gY - 20, w: 40, h: 20, color: '#ff4444' });
    } else if (type === 'spikeHigh') {
        obstacles.push({ type: 'spikeHigh', x, y: gY - 120, w: 60, h: 20, color: '#ff4444' });
    } else if (type === 'pendulum') {
        obstacles.push({
            type: 'pendulum', x, y: gY - 140,
            pivotY: gY - 200, angle: 0, length: 80,
            w: 25, h: 25, speed: 0.02 + Math.random() * 0.02, color: '#cc44cc'
        });
    }
}

function getObstacleColor() {
    const colors = ['#cc3333', '#cc6633', '#996633', '#666666', '#883388'];
    return colors[Math.floor(Math.random() * colors.length)];
}

function spawnCoins() {
    const x = canvas.width + 50;
    const gY = groundY;
    const patterns = ['line', 'arc', 'zigzag'];
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
    const count = 5 + Math.floor(Math.random() * 6);

    for (let i = 0; i < count; i++) {
        let cx, cy;
        if (pattern === 'line') {
            cx = x + i * 35;
            cy = gY - 40 - Math.random() * 60;
        } else if (pattern === 'arc') {
            cx = x + i * 35;
            const mid = count / 2;
            const arcH = 80;
            cy = gY - 40 - arcH * (1 - Math.pow((i - mid) / mid, 2));
        } else {
            cx = x + i * 35;
            cy = gY - 40 - (i % 2 === 0 ? 20 : 80);
        }
        coinList.push({ x: cx, y: cy, r: 8, collected: false, animTimer: Math.random() * Math.PI * 2 });
    }
}

function spawnPowerup() {
    const x = canvas.width + 50;
    const gY = groundY;
    const types = ['magnet', 'shield', 'multiplier', 'jetpack'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push({
        type, x, y: gY - 60 - Math.random() * 80, w: 24, h: 24,
        collected: false, animTimer: 0
    });
}

// ---- UPDATE ----
function update() {
    if (state !== STATE.PLAYING) return;

    groundY = canvas.height - 80;

    // Speed increase
    baseSpeed = 6 + distanceMetres / 400;
    gameSpeed = baseSpeed * speedMultiplier;

    // Distance
    distance += gameSpeed;
    distanceMetres = Math.floor(distance / 10);

    // Theme changes every 500m
    const newTheme = Math.floor(distanceMetres / 500) % 4;
    if (newTheme !== currentTheme) {
        currentTheme = newTheme;
        sfxMilestone();
    }

    // Spawn
    spawnTimer++;
    const adjustedInterval = Math.max(40, spawnInterval - distanceMetres / 15);
    if (spawnTimer >= adjustedInterval) {
        spawnTimer = 0;
        spawnObstacle();
    }

    coinSpawnTimer++;
    if (coinSpawnTimer >= 80) {
        coinSpawnTimer = 0;
        spawnCoins();
    }

    powerupSpawnTimer++;
    if (powerupSpawnTimer >= 500 + Math.random() * 300) {
        powerupSpawnTimer = 0;
        spawnPowerup();
    }

    // Timers
    if (hasMagnet) { magnetTimer--; if (magnetTimer <= 0) hasMagnet = false; }
    if (scoreMultiplier > 1) { multiplierTimer--; if (multiplierTimer <= 0) scoreMultiplier = 1; }
    if (hasJetpack) {
        jetpackTimer--;
        if (jetpackTimer <= 0) {
            hasJetpack = false;
            player.vy = 0;
        }
    }
    if (player.invincible > 0) player.invincible--;

    // --- Player physics ---
    const jumpKey = keys['Space'] || keys['ArrowUp'];
    const slideKey = keys['ArrowDown'] || keys['KeyS'];

    // Jetpack overrides
    if (hasJetpack) {
        player.y = groundY - 180;
        player.vy = 0;
        player.onGround = false;
        player.sliding = false;
    } else {
        // Jump
        if (jumpPressed) {
            const now = Date.now();
            if (player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
                player.jumping = true;
                player.jumpHeld = true;
                player.jumpTime = 0;
                player.doubleJumped = false;
                player.sliding = false;
                player.h = PLAYER_NORMAL_H;
                sfxJump();
            } else if (!player.doubleJumped) {
                // Double jump
                player.vy = JUMP_FORCE * 0.85;
                player.doubleJumped = true;
                player.jumpHeld = true;
                player.jumpTime = 0;
                sfxDoubleJump();
            }
            lastJumpPress = now;
            jumpPressed = false;
        }

        // Hold jump for higher
        if (jumpKey && player.jumpHeld && player.jumpTime < MAX_JUMP_HOLD) {
            player.vy += JUMP_HOLD_FORCE;
            player.jumpTime++;
        }
        if (!jumpKey) {
            player.jumpHeld = false;
        }

        // Slide
        if (slidePressed && player.onGround && !player.sliding) {
            player.sliding = true;
            player.slideTimer = SLIDE_DURATION;
            player.h = PLAYER_SLIDE_H;
            player.y = groundY - PLAYER_SLIDE_H;
            sfxSlide();
            slidePressed = false;
        } else {
            slidePressed = false;
        }

        if (player.sliding) {
            player.slideTimer--;
            if (player.slideTimer <= 0 || (!slideKey && player.slideTimer < SLIDE_DURATION - 10)) {
                player.sliding = false;
                player.h = PLAYER_NORMAL_H;
                player.y = groundY - PLAYER_NORMAL_H;
            }
        }

        // Gravity
        player.vy += GRAVITY;
        player.y += player.vy;

        // Ground collision (check for gaps)
        let overGap = false;
        for (const gap of gaps) {
            if (player.x + player.w > gap.x && player.x < gap.x + gap.w) {
                overGap = true;
                break;
            }
        }

        if (!overGap && player.y + player.h >= groundY) {
            player.y = groundY - player.h;
            player.vy = 0;
            player.onGround = true;
            player.jumping = false;
            player.doubleJumped = false;
        } else if (overGap) {
            player.onGround = false;
        }

        // Fall into gap = death
        if (player.y > canvas.height + 50) {
            killPlayer();
            return;
        }
    }

    // Animation
    player.animTimer += gameSpeed * 0.1;
    if (player.animTimer > 1) {
        player.animTimer = 0;
        player.animFrame = (player.animFrame + 1) % 4;
    }

    // Move obstacles
    for (const obs of obstacles) {
        obs.x -= gameSpeed;
        if (obs.type === 'pendulum') {
            obs.angle += obs.speed;
            obs.px = obs.x + Math.sin(obs.angle) * obs.length;
            obs.py = obs.pivotY + Math.cos(obs.angle) * obs.length;
        }
    }
    obstacles = obstacles.filter(o => o.x > -100);

    // Move gaps
    for (const gap of gaps) gap.x -= gameSpeed;
    gaps = gaps.filter(g => g.x + g.w > -50);

    // Move & collect coins
    for (const c of coinList) {
        c.x -= gameSpeed;
        c.animTimer += 0.05;

        // Magnet effect
        if (hasMagnet && !c.collected) {
            const dx = player.x + player.w / 2 - c.x;
            const dy = player.y + player.h / 2 - c.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 200) {
                c.x += dx * 0.1;
                c.y += dy * 0.1;
            }
        }

        if (!c.collected && collides(player, { x: c.x - c.r, y: c.y - c.r, w: c.r * 2, h: c.r * 2 })) {
            c.collected = true;
            coins++;
            sfxCoin();
            spawnParticles(c.x, c.y, '#ffdd00', 5);
        }
    }
    coinList = coinList.filter(c => c.x > -50 && !c.collected);

    // Move & collect powerups
    for (const p of powerups) {
        p.x -= gameSpeed;
        p.animTimer += 0.05;
        if (!p.collected && collides(player, { x: p.x - p.w / 2, y: p.y - p.h / 2, w: p.w, h: p.h })) {
            p.collected = true;
            activatePowerup(p.type);
            sfxPowerup();
            spawnParticles(p.x, p.y, '#00ffaa', 8);
        }
    }
    powerups = powerups.filter(p => p.x > -50 && !p.collected);

    // Collision with obstacles
    if (player.invincible <= 0 && !hasJetpack) {
        for (const obs of obstacles) {
            let ox, oy, ow, oh;
            if (obs.type === 'pendulum') {
                ox = obs.px - obs.w / 2;
                oy = obs.py - obs.h / 2;
                ow = obs.w;
                oh = obs.h;
            } else {
                ox = obs.x; oy = obs.y; ow = obs.w; oh = obs.h;
            }
            if (collides(player, { x: ox, y: oy, w: ow, h: oh })) {
                if (hasShield) {
                    hasShield = false;
                    player.invincible = 60;
                    sfxHit();
                    spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#44aaff', 10);
                } else {
                    killPlayer();
                    return;
                }
            }
        }
    }

    // Update particles
    for (const p of particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
    }
    particles = particles.filter(p => p.life > 0);

    // Background layers scroll
    for (let l = 0; l < 3; l++) {
        const layerSpeed = gameSpeed * (0.2 + l * 0.3);
        for (const obj of bgLayers[l]) {
            obj.x -= layerSpeed;
            if (obj.x + obj.w < 0) {
                obj.x = canvas.width + Math.random() * 200;
                obj.type = Math.floor(Math.random() * 3);
                obj.h = 30 + Math.random() * (60 + l * 40);
                obj.w = 20 + Math.random() * (40 + l * 20);
            }
        }
    }

    // Score
    score = distanceMetres * scoreMultiplier + coins * 10;
}

function collides(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function killPlayer() {
    player.alive = false;
    sfxHit();
    spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff4444', 20);
    state = STATE.GAMEOVER;
    score = distanceMetres + coins * 10;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('endlessRunnerHigh', highScore);
    }
    backBtn.style.display = 'block';
}

function activatePowerup(type) {
    if (type === 'magnet') { hasMagnet = true; magnetTimer = 600; } // 10s at 60fps
    else if (type === 'shield') { hasShield = true; }
    else if (type === 'multiplier') { scoreMultiplier = 2; multiplierTimer = 900; } // 15s
    else if (type === 'jetpack') { hasJetpack = true; jetpackTimer = 480; } // 8s
}

function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6 - 2,
            color, life: 30 + Math.random() * 20,
            r: 2 + Math.random() * 3
        });
    }
}

// ---- DRAW ----
function draw() {
    const W = canvas.width;
    const H = canvas.height;
    const theme = themes[currentTheme];

    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
    skyGrad.addColorStop(0, theme.sky[0]);
    skyGrad.addColorStop(0.5, theme.sky[1]);
    skyGrad.addColorStop(1, theme.sky[2]);
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H);

    // Stars (for city/snow themes)
    if (currentTheme === 0 || currentTheme === 3) {
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i < 50; i++) {
            const sx = ((i * 137 + distance * 0.01) % W);
            const sy = ((i * 97) % (H * 0.5));
            ctx.fillRect(sx, sy, 1.5, 1.5);
        }
    }

    // Sun/Moon
    if (currentTheme === 2) {
        // Desert sun
        ctx.fillStyle = '#ffcc44';
        ctx.beginPath();
        ctx.arc(W * 0.8, H * 0.15, 40, 0, Math.PI * 2);
        ctx.fill();
    } else if (currentTheme === 0) {
        // City moon
        ctx.fillStyle = '#ddeeff';
        ctx.beginPath();
        ctx.arc(W * 0.85, H * 0.1, 25, 0, Math.PI * 2);
        ctx.fill();
    }

    // Parallax background layers
    drawBgLayers();

    if (state === STATE.PLAYING || state === STATE.GAMEOVER || state === STATE.PAUSED) {
        drawGround(theme);
        drawGaps();
        drawObstacles();
        drawCoins();
        drawPowerups();
        drawPlayer();
        drawParticles();
        drawHUD();
    }

    if (state === STATE.MENU) drawMenu();
    if (state === STATE.GAMEOVER) drawGameOver();
    if (state === STATE.PAUSED) drawPaused();
}

function drawBgLayers() {
    const gY = state === STATE.PLAYING || state === STATE.GAMEOVER || state === STATE.PAUSED ? groundY : canvas.height - 80;
    const theme = themes[currentTheme];
    const layerAlpha = [0.15, 0.25, 0.4];
    const layerColors = {
        0: ['#334', '#445', '#556'], // city
        1: ['#1a3a1a', '#2a5a2a', '#1a4a1a'], // forest
        2: ['#8a6a3a', '#a08050', '#c09a60'], // desert
        3: ['#6a8aaa', '#8aaabb', '#aaccdd']  // snow
    };

    for (let l = 0; l < 3; l++) {
        const baseY = gY - 20 - l * 30;
        for (const obj of bgLayers[l]) {
            ctx.globalAlpha = layerAlpha[l];
            ctx.fillStyle = layerColors[currentTheme][l];

            if (theme.bgElements === 'city') {
                // Buildings
                ctx.fillRect(obj.x, baseY - obj.h, obj.w, obj.h + 20);
                // Windows
                ctx.fillStyle = 'rgba(255,255,150,0.3)';
                for (let wy = baseY - obj.h + 8; wy < baseY - 5; wy += 14) {
                    for (let wx = obj.x + 4; wx < obj.x + obj.w - 6; wx += 10) {
                        ctx.fillRect(wx, wy, 5, 7);
                    }
                }
                ctx.fillStyle = layerColors[currentTheme][l];
            } else if (theme.bgElements === 'forest') {
                // Trees
                ctx.fillStyle = '#3a2a1a';
                ctx.globalAlpha = layerAlpha[l] * 0.8;
                ctx.fillRect(obj.x + obj.w * 0.35, baseY - obj.h * 0.5, obj.w * 0.3, obj.h * 0.5 + 20);
                ctx.fillStyle = layerColors[currentTheme][l];
                ctx.globalAlpha = layerAlpha[l];
                ctx.beginPath();
                ctx.moveTo(obj.x, baseY - obj.h * 0.3);
                ctx.lineTo(obj.x + obj.w / 2, baseY - obj.h);
                ctx.lineTo(obj.x + obj.w, baseY - obj.h * 0.3);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(obj.x + 3, baseY - obj.h * 0.15);
                ctx.lineTo(obj.x + obj.w / 2, baseY - obj.h * 0.7);
                ctx.lineTo(obj.x + obj.w - 3, baseY - obj.h * 0.15);
                ctx.fill();
            } else if (theme.bgElements === 'desert') {
                // Sand dunes / cacti
                if (obj.type === 0) {
                    ctx.beginPath();
                    ctx.moveTo(obj.x - obj.w, baseY + 10);
                    ctx.quadraticCurveTo(obj.x + obj.w / 2, baseY - obj.h, obj.x + obj.w * 2, baseY + 10);
                    ctx.fill();
                } else {
                    // Cactus
                    ctx.fillStyle = '#2a6a2a';
                    ctx.globalAlpha = layerAlpha[l];
                    ctx.fillRect(obj.x + obj.w * 0.4, baseY - obj.h, obj.w * 0.2, obj.h);
                    ctx.fillRect(obj.x, baseY - obj.h * 0.7, obj.w * 0.4, obj.w * 0.15);
                    ctx.fillRect(obj.x + obj.w * 0.6, baseY - obj.h * 0.5, obj.w * 0.4, obj.w * 0.15);
                    ctx.fillRect(obj.x, baseY - obj.h * 0.7, obj.w * 0.15, obj.h * 0.3);
                    ctx.fillRect(obj.x + obj.w * 0.85, baseY - obj.h * 0.5, obj.w * 0.15, obj.h * 0.25);
                }
            } else if (theme.bgElements === 'snow') {
                // Snow hills / pine trees
                if (obj.type === 0) {
                    ctx.beginPath();
                    ctx.moveTo(obj.x - obj.w * 0.5, baseY + 10);
                    ctx.quadraticCurveTo(obj.x + obj.w / 2, baseY - obj.h * 0.5, obj.x + obj.w * 1.5, baseY + 10);
                    ctx.fill();
                } else {
                    // Snow pine
                    ctx.fillStyle = '#1a4a2a';
                    ctx.globalAlpha = layerAlpha[l];
                    ctx.beginPath();
                    ctx.moveTo(obj.x + obj.w / 2, baseY - obj.h);
                    ctx.lineTo(obj.x, baseY);
                    ctx.lineTo(obj.x + obj.w, baseY);
                    ctx.fill();
                    // Snow caps
                    ctx.fillStyle = '#eef';
                    ctx.globalAlpha = layerAlpha[l] * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(obj.x + obj.w / 2, baseY - obj.h);
                    ctx.lineTo(obj.x + obj.w * 0.3, baseY - obj.h * 0.6);
                    ctx.lineTo(obj.x + obj.w * 0.7, baseY - obj.h * 0.6);
                    ctx.fill();
                }
            }
        }
    }
    ctx.globalAlpha = 1;
}

function drawGround(theme) {
    const gY = groundY;

    // Draw gaps as missing ground
    // First draw full ground, then "cut" gaps
    ctx.fillStyle = theme.ground;

    // Build ground segments around gaps
    let segments = [];
    let sortedGaps = [...gaps].sort((a, b) => a.x - b.x);
    let lastX = 0;
    for (const gap of sortedGaps) {
        if (gap.x > lastX) {
            segments.push({ x: lastX, w: gap.x - lastX });
        }
        lastX = gap.x + gap.w;
    }
    if (lastX < canvas.width) {
        segments.push({ x: lastX, w: canvas.width - lastX });
    }

    for (const seg of segments) {
        ctx.fillRect(seg.x, gY, seg.w, canvas.height - gY);
    }

    // Ground line detail
    ctx.strokeStyle = theme.groundLine;
    ctx.lineWidth = 2;
    for (const seg of segments) {
        ctx.beginPath();
        ctx.moveTo(seg.x, gY);
        ctx.lineTo(seg.x + seg.w, gY);
        ctx.stroke();
    }

    // Ground texture lines
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i < canvas.width; i += 20) {
        const x = (i - distance * 0.5) % canvas.width;
        if (x > 0) {
            // Check if in gap
            let inGap = false;
            for (const gap of gaps) { if (x > gap.x && x < gap.x + gap.w) { inGap = true; break; } }
            if (!inGap) {
                ctx.beginPath();
                ctx.moveTo(x, gY + 5);
                ctx.lineTo(x + 10, gY + 5);
                ctx.stroke();
            }
        }
    }

    // Snow theme: ice patches
    if (currentTheme === 3) {
        ctx.fillStyle = 'rgba(150,200,255,0.3)';
        for (let i = 0; i < 5; i++) {
            const ix = ((i * 300 + 100 - distance * 0.8) % (canvas.width + 400)) - 100;
            ctx.fillRect(ix, gY + 1, 80, 4);
        }
    }
}

function drawGaps() {
    // Draw danger lines at gap edges
    for (const gap of gaps) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(gap.x, groundY, gap.w, canvas.height - groundY);

        // Warning stripes on edges
        ctx.fillStyle = '#cc4444';
        ctx.fillRect(gap.x - 3, groundY, 3, 30);
        ctx.fillRect(gap.x + gap.w, groundY, 3, 30);
    }
}

function drawObstacles() {
    for (const obs of obstacles) {
        ctx.fillStyle = obs.color;

        if (obs.type === 'low') {
            // Barrier block
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(obs.x, obs.y, obs.w, 4);
            // Warning stripe
            ctx.fillStyle = '#ffcc00';
            for (let i = 0; i < obs.w; i += 12) {
                ctx.fillRect(obs.x + i, obs.y, 6, 4);
            }
        } else if (obs.type === 'high') {
            // Overhead barrier
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            // Support poles
            ctx.fillStyle = 'rgba(100,100,100,0.8)';
            ctx.fillRect(obs.x, obs.y, 4, groundY - obs.y);
            ctx.fillRect(obs.x + obs.w - 4, obs.y, 4, groundY - obs.y);
            // Stripe
            ctx.fillStyle = '#ffcc00';
            for (let i = 0; i < obs.w; i += 14) {
                ctx.fillRect(obs.x + i, obs.y + obs.h - 5, 7, 5);
            }
        } else if (obs.type === 'spikeLow') {
            drawSpikes(obs.x, obs.y, obs.w, obs.h, false);
        } else if (obs.type === 'spikeHigh') {
            drawSpikes(obs.x, obs.y, obs.w, obs.h, true);
        } else if (obs.type === 'pendulum') {
            // Draw chain
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.pivotY);
            ctx.lineTo(obs.px, obs.py);
            ctx.stroke();
            // Pivot
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(obs.x, obs.pivotY, 5, 0, Math.PI * 2);
            ctx.fill();
            // Ball
            ctx.fillStyle = obs.color;
            ctx.beginPath();
            ctx.arc(obs.px, obs.py, obs.w / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.arc(obs.px - 3, obs.py - 3, obs.w / 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

function drawSpikes(x, y, w, h, inverted) {
    ctx.fillStyle = '#ff4444';
    const spikeW = 12;
    const count = Math.floor(w / spikeW);
    for (let i = 0; i < count; i++) {
        ctx.beginPath();
        if (inverted) {
            ctx.moveTo(x + i * spikeW, y);
            ctx.lineTo(x + i * spikeW + spikeW / 2, y + h);
            ctx.lineTo(x + (i + 1) * spikeW, y);
        } else {
            ctx.moveTo(x + i * spikeW, y + h);
            ctx.lineTo(x + i * spikeW + spikeW / 2, y);
            ctx.lineTo(x + (i + 1) * spikeW, y + h);
        }
        ctx.fill();
    }
}

function drawCoins() {
    for (const c of coinList) {
        if (c.collected) continue;
        const bob = Math.sin(c.animTimer) * 3;
        const squeeze = 0.6 + Math.abs(Math.sin(c.animTimer * 2)) * 0.4;

        ctx.save();
        ctx.translate(c.x, c.y + bob);
        ctx.scale(squeeze, 1);

        // Outer
        ctx.fillStyle = '#ffdd00';
        ctx.beginPath();
        ctx.arc(0, 0, c.r, 0, Math.PI * 2);
        ctx.fill();

        // Inner
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(0, 0, c.r * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(-2, -2, c.r * 0.3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

function drawPowerups() {
    for (const p of powerups) {
        if (p.collected) continue;
        const bob = Math.sin(p.animTimer * 3) * 4;
        const glow = 0.3 + Math.sin(p.animTimer * 5) * 0.2;

        ctx.save();
        ctx.translate(p.x, p.y + bob);

        // Glow
        ctx.fillStyle = `rgba(255,255,255,${glow})`;
        ctx.beginPath();
        ctx.arc(0, 0, p.w, 0, Math.PI * 2);
        ctx.fill();

        // Icon background
        let color;
        let icon;
        if (p.type === 'magnet') { color = '#ff4488'; icon = 'M'; }
        else if (p.type === 'shield') { color = '#4488ff'; icon = 'S'; }
        else if (p.type === 'multiplier') { color = '#44ff88'; icon = 'x2'; }
        else if (p.type === 'jetpack') { color = '#ff8844'; icon = 'J'; }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, p.w / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, 0, 0);

        ctx.restore();
    }
}

function drawPlayer() {
    if (!player.alive) return;

    const px = player.x;
    const py = player.y;
    const pw = player.w;
    const ph = player.h;

    // Shield aura
    if (hasShield) {
        ctx.strokeStyle = 'rgba(68,136,255,0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(px + pw / 2, py + ph / 2, ph * 0.7, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Jetpack flames
    if (hasJetpack) {
        const flameH = 10 + Math.random() * 15;
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(px + 2, py + ph);
        ctx.lineTo(px + pw / 2, py + ph + flameH);
        ctx.lineTo(px + pw - 2, py + ph);
        ctx.fill();
        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.moveTo(px + 6, py + ph);
        ctx.lineTo(px + pw / 2, py + ph + flameH * 0.6);
        ctx.lineTo(px + pw - 6, py + ph);
        ctx.fill();
    }

    // Blink if invincible
    if (player.invincible > 0 && Math.floor(player.invincible / 3) % 2 === 0) return;

    ctx.save();
    ctx.translate(px, py);

    if (player.sliding) {
        // Sliding pose - horizontal rectangle
        const bodyColor = hasJetpack ? '#ff8844' : '#44aaff';
        ctx.fillStyle = bodyColor;
        ctx.fillRect(0, 5, pw + 10, ph - 5);
        // Head
        ctx.fillStyle = '#ffcc88';
        ctx.beginPath();
        ctx.arc(pw + 6, 10, 8, 0, Math.PI * 2);
        ctx.fill();
        // Visor
        ctx.fillStyle = '#333';
        ctx.fillRect(pw + 4, 7, 8, 4);
    } else {
        const bodyColor = hasJetpack ? '#ff8844' : '#44aaff';

        // Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(4, 16, pw - 8, ph - 30);

        // Head
        ctx.fillStyle = '#ffcc88';
        ctx.beginPath();
        ctx.arc(pw / 2, 10, 10, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = '#553322';
        ctx.beginPath();
        ctx.arc(pw / 2, 6, 10, Math.PI, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#333';
        ctx.fillRect(pw / 2 + 2, 8, 3, 3);

        // Legs
        const legAnim = Math.sin(player.animFrame * Math.PI / 2) * 8;
        ctx.fillStyle = '#335';
        // Left leg
        ctx.fillRect(8, ph - 16, 6, 16);
        // Right leg
        ctx.fillRect(pw - 14, ph - 16, 6, 16);

        if (!player.onGround) {
            // In air: legs tucked or spread
            ctx.clearRect(0, ph - 16, pw, 16);
            ctx.fillStyle = '#335';
            if (player.vy < 0) {
                // Going up - legs together
                ctx.fillRect(10, ph - 12, 5, 12);
                ctx.fillRect(pw - 15, ph - 12, 5, 12);
            } else {
                // Falling - legs spread
                ctx.save();
                ctx.translate(10, ph - 14);
                ctx.rotate(-0.3);
                ctx.fillRect(0, 0, 5, 14);
                ctx.restore();
                ctx.save();
                ctx.translate(pw - 12, ph - 14);
                ctx.rotate(0.3);
                ctx.fillRect(0, 0, 5, 14);
                ctx.restore();
            }
        } else {
            // Running animation
            ctx.clearRect(0, ph - 16, pw, 16);
            ctx.fillStyle = '#335';
            ctx.save();
            ctx.translate(10, ph - 14);
            ctx.rotate(Math.sin(player.animFrame * Math.PI / 2) * 0.4);
            ctx.fillRect(-2, 0, 5, 14);
            ctx.restore();
            ctx.save();
            ctx.translate(pw - 12, ph - 14);
            ctx.rotate(-Math.sin(player.animFrame * Math.PI / 2) * 0.4);
            ctx.fillRect(-2, 0, 5, 14);
            ctx.restore();
        }

        // Arms
        ctx.fillStyle = bodyColor;
        const armSwing = Math.sin(player.animFrame * Math.PI / 2) * 0.5;
        ctx.save();
        ctx.translate(2, 20);
        ctx.rotate(-0.3 + armSwing);
        ctx.fillRect(-2, 0, 5, 16);
        ctx.restore();
        ctx.save();
        ctx.translate(pw - 4, 20);
        ctx.rotate(0.3 - armSwing);
        ctx.fillRect(-2, 0, 5, 16);
        ctx.restore();

        // Shoes
        ctx.fillStyle = '#aa2222';
        if (player.onGround) {
            ctx.fillRect(6, ph - 4, 8, 4);
            ctx.fillRect(pw - 16, ph - 4, 8, 4);
        }
    }

    ctx.restore();

    // Magnet indicator
    if (hasMagnet) {
        ctx.strokeStyle = 'rgba(255,68,136,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(player.x + pw / 2, player.y + ph / 2, 200, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

function drawParticles() {
    for (const p of particles) {
        ctx.globalAlpha = p.life / 50;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawHUD() {
    const W = canvas.width;

    // Distance
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(W - 200, 10, 190, 70);
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - 200, 10, 190, 70);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'right';
    ctx.fillText(`${distanceMetres}m`, W - 20, 36);

    ctx.fillStyle = '#ffdd00';
    ctx.font = '16px Arial';
    ctx.fillText(`Coins: ${coins}`, W - 20, 58);

    ctx.fillStyle = '#aaa';
    ctx.font = '12px Arial';
    ctx.fillText(`Score: ${Math.floor(score)}`, W - 20, 74);

    // Power-up indicators
    let indicatorY = 90;
    if (hasShield) {
        drawIndicator(W - 195, indicatorY, '#4488ff', 'SHIELD', 1);
        indicatorY += 24;
    }
    if (hasMagnet) {
        drawIndicator(W - 195, indicatorY, '#ff4488', 'MAGNET', magnetTimer / 600);
        indicatorY += 24;
    }
    if (scoreMultiplier > 1) {
        drawIndicator(W - 195, indicatorY, '#44ff88', 'x2 SCORE', multiplierTimer / 900);
        indicatorY += 24;
    }
    if (hasJetpack) {
        drawIndicator(W - 195, indicatorY, '#ff8844', 'JETPACK', jetpackTimer / 480);
        indicatorY += 24;
    }

    // Theme name
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(themes[currentTheme].name.toUpperCase(), 15, canvas.height - 15);

    // Speed indicator
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText(`Speed: ${gameSpeed.toFixed(1)}`, 15, canvas.height - 32);
}

function drawIndicator(x, y, color, text, pct) {
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(x, y, 185, 20);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.4;
    ctx.fillRect(x, y, 185 * pct, 20);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(text, x + 6, y + 14);
}

function drawMenu() {
    const W = canvas.width;
    const H = canvas.height;

    // Overlay
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, W, H);

    // Decorative ground
    ctx.fillStyle = '#444';
    ctx.fillRect(0, H - 80, W, 80);

    // Layout: title area at top, play button in middle, controls panel below
    const titleY = Math.min(H * 0.18, 120);

    // Title glow
    ctx.shadowColor = '#44aaff';
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 56px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ENDLESS RUNNER', W / 2, titleY);
    ctx.shadowBlur = 0;

    // Subtitle
    ctx.fillStyle = '#aaccff';
    ctx.font = '18px Arial';
    ctx.fillText('Run. Jump. Slide. Survive.', W / 2, titleY + 36);

    // Play button
    const bx = W / 2;
    const by = titleY + 100;
    ctx.fillStyle = '#44cc44';
    ctx.beginPath();
    roundRect(ctx, bx - 100, by - 28, 200, 56, 12);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px Arial';
    ctx.fillText('PLAY', bx, by + 8);

    // High score
    if (highScore > 0) {
        ctx.fillStyle = '#ffdd00';
        ctx.font = '16px Arial';
        ctx.fillText(`High Score: ${highScore}`, W / 2, by + 55);
    }

    // ---- CONTROLS PANEL ----
    const controlsData = [
        { key: 'Space / Up', desc: 'Jump (hold for higher)' },
        { key: 'Double tap', desc: 'Double jump' },
        { key: 'Down / S',   desc: 'Slide' },
        { key: 'P',          desc: 'Pause' },
        { key: 'ESC',        desc: 'Main menu' }
    ];

    const lineHeight = 30;
    const headingFont = 'bold 22px Arial';
    const keyFont = 'bold 17px Arial';
    const descFont = '17px Arial';
    const panelPadTop = 18;
    const panelPadBot = 16;
    const headingHeight = 32;
    const panelContentH = headingHeight + controlsData.length * lineHeight;
    const panelH = panelPadTop + panelContentH + panelPadBot;
    const panelW = 360;
    const panelX = W / 2 - panelW / 2;
    const panelY = by + (highScore > 0 ? 75 : 55);

    // Semi-transparent dark panel background
    ctx.fillStyle = 'rgba(10, 10, 30, 0.75)';
    ctx.beginPath();
    roundRect(ctx, panelX, panelY, panelW, panelH, 14);
    ctx.fill();

    // Panel border
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundRect(ctx, panelX, panelY, panelW, panelH, 14);
    ctx.stroke();

    // "CONTROLS" heading
    const headingY = panelY + panelPadTop + 20;
    ctx.fillStyle = '#FFD700';
    ctx.font = headingFont;
    ctx.textAlign = 'center';
    ctx.fillText('CONTROLS', W / 2, headingY);

    // Thin separator line under heading
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(panelX + 24, headingY + 10);
    ctx.lineTo(panelX + panelW - 24, headingY + 10);
    ctx.stroke();

    // Control lines
    const startY = headingY + 14 + lineHeight;
    const keyColX = panelX + 28;             // left-aligned keys
    const descColX = panelX + panelW / 2 + 16; // descriptions after middle
    ctx.textAlign = 'left';

    for (let i = 0; i < controlsData.length; i++) {
        const y = startY + i * lineHeight;

        // Key label in gold
        ctx.fillStyle = '#FFD700';
        ctx.font = keyFont;
        ctx.fillText(controlsData[i].key, keyColX, y);

        // Description in white
        ctx.fillStyle = '#FFFFFF';
        ctx.font = descFont;
        ctx.fillText(controlsData[i].desc, descColX, y);
    }

    // Mobile hint below the panel
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(170, 200, 255, 0.6)';
    ctx.font = '14px Arial';
    ctx.fillText('Mobile: Tap top half to jump, bottom half to slide', W / 2, panelY + panelH + 22);

    // Jake's Arcade branding
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '12px Arial';
    ctx.fillText("Jake's Arcade", W / 2, H - 20);
}

function drawGameOver() {
    const W = canvas.width;
    const H = canvas.height;

    // Overlay
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    // Panel
    ctx.fillStyle = 'rgba(30,30,50,0.95)';
    ctx.beginPath();
    roundRect(ctx, W / 2 - 180, H / 2 - 150, 360, 300, 16);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundRect(ctx, W / 2 - 180, H / 2 - 150, 360, 300, 16);
    ctx.stroke();

    // Title
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 100);

    // Stats
    ctx.fillStyle = '#fff';
    ctx.font = '20px Arial';
    ctx.fillText(`Distance: ${distanceMetres}m`, W / 2, H / 2 - 50);

    ctx.fillStyle = '#ffdd00';
    ctx.fillText(`Coins: ${coins}`, W / 2, H / 2 - 20);

    ctx.fillStyle = '#44ff88';
    ctx.font = 'bold 22px Arial';
    ctx.fillText(`Score: ${Math.floor(score)}`, W / 2, H / 2 + 15);

    // High score
    if (score >= highScore) {
        ctx.fillStyle = '#ffdd00';
        ctx.font = 'bold 18px Arial';
        ctx.fillText('NEW HIGH SCORE!', W / 2, H / 2 + 48);
    } else {
        ctx.fillStyle = '#aaa';
        ctx.font = '16px Arial';
        ctx.fillText(`High Score: ${highScore}`, W / 2, H / 2 + 48);
    }

    // Play again button
    const bx = W / 2;
    const by = H / 2 + 100;
    ctx.fillStyle = '#44cc44';
    ctx.beginPath();
    roundRect(ctx, bx - 100, by - 25, 200, 50, 10);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.fillText('PLAY AGAIN', bx, by + 7);
}

function drawPaused() {
    const W = canvas.width;
    const H = canvas.height;

    // Dark overlay
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);

    // PAUSED title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W / 2, H / 2 - 60);

    // RESUME button (green #4a4)
    const resumeY = H / 2 + 10;
    ctx.fillStyle = '#44aa44';
    ctx.beginPath();
    roundRect(ctx, W / 2 - 130, resumeY - 25, 260, 50, 10);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.fillText('RESUME', W / 2, resumeY + 8);

    // MAIN MENU button (red #c44)
    const menuY = H / 2 + 75;
    ctx.fillStyle = '#cc4444';
    ctx.beginPath();
    roundRect(ctx, W / 2 - 130, menuY - 25, 260, 50, 10);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.fillText('MAIN MENU', W / 2, menuY + 8);

    // Help text
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Arial';
    ctx.fillText('Press P to resume | ESC for main menu', W / 2, H / 2 + 130);
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
}

// ---- GAME FLOW ----
function startGame() {
    ensureAudio();
    resetGame();
    state = STATE.PLAYING;
    backBtn.style.display = 'none';
}

function goToMenu() {
    state = STATE.MENU;
    backBtn.style.display = 'block';
    initBgLayers();
}

// ---- GAME LOOP ----
let menuBgScroll = 0;

function gameLoop(time) {
    if (lastTime === 0) lastTime = time;
    dt = Math.min((time - lastTime) / 16.67, 3); // cap dt
    lastTime = time;

    // Menu background animation
    if (state === STATE.MENU) {
        menuBgScroll += 1;
        for (let l = 0; l < 3; l++) {
            const layerSpeed = 0.5 + l * 0.3;
            for (const obj of bgLayers[l]) {
                obj.x -= layerSpeed;
                if (obj.x + obj.w < 0) {
                    obj.x = canvas.width + Math.random() * 200;
                }
            }
        }
    }

    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Initialize
groundY = canvas.height - 80;
initBgLayers();
backBtn.style.display = 'block';

requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>