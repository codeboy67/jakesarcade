<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:; frame-ancestors 'none'; base-uri 'self'; form-action 'none'">
<meta name="referrer" content="no-referrer">
<title>Pong Championship - Jake's Arcade</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #0a0a1a;
    overflow: hidden;
    font-family: 'Segoe UI', Arial, sans-serif;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
}
canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    touch-action: none;
}
#backLink {
    position: fixed;
    top: 12px;
    left: 16px;
    color: #8888cc;
    text-decoration: none;
    font-size: 14px;
    z-index: 100;
    opacity: 0.7;
    transition: opacity 0.2s;
    font-family: 'Segoe UI', Arial, sans-serif;
}
#backLink:hover { opacity: 1; color: #aaaaff; }
</style>
</head>
<body>
<a id="backLink" href="../../index.html">&larr; Back to Jake's Arcade</a>
<canvas id="gameCanvas"></canvas>
<script>
// ============================================================
// PONG CHAMPIONSHIP - Jake's Arcade
// ============================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const backLink = document.getElementById('backLink');

// --- Audio Engine ---
let audioCtx = null;
function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, duration, type, vol) {
    type = type || 'square';
    vol = vol !== undefined ? vol : 0.12;
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    } catch(e) {}
}

function playHit() { playTone(440, 0.08, 'square', 0.1); }
function playWallHit() { playTone(330, 0.06, 'triangle', 0.08); }
function playScore() {
    playTone(523, 0.15, 'square', 0.15);
    setTimeout(function(){ playTone(659, 0.15, 'square', 0.15); }, 100);
    setTimeout(function(){ playTone(784, 0.2, 'square', 0.15); }, 200);
}
function playPowerup() {
    playTone(880, 0.1, 'sine', 0.12);
    setTimeout(function(){ playTone(1100, 0.1, 'sine', 0.12); }, 60);
    setTimeout(function(){ playTone(1320, 0.15, 'sine', 0.12); }, 120);
}
function playAbility() {
    playTone(200, 0.3, 'sawtooth', 0.1);
    playTone(400, 0.3, 'square', 0.08);
}
function playFreeze() {
    playTone(1200, 0.2, 'sine', 0.12);
    setTimeout(function(){ playTone(800, 0.3, 'sine', 0.1); }, 100);
}
function playMenuSelect() { playTone(600, 0.1, 'square', 0.08); }
function playMenuConfirm() {
    playTone(500, 0.1, 'square', 0.1);
    setTimeout(function(){ playTone(700, 0.15, 'square', 0.1); }, 80);
}
function playGameWin() {
    var notes = [523, 659, 784, 1047, 1319];
    for (var i = 0; i < notes.length; i++) {
        (function(idx){ setTimeout(function(){ playTone(notes[idx], 0.25, 'square', 0.12); }, idx * 150); })(i);
    }
}
// --- Canvas Resize ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- Touch Device Detection ---
var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

// Touch state
var touchPaddleId = null;   // identifier of the touch controlling the paddle
var touchPaddleActive = false;
var touchAbilityBtnRadius = 50;
var touchPauseBtnRadius = 22;

// On-screen keyboard for name entry on touch devices
var touchKeyboard = {
    visible: false,
    keys: [
        ['Q','W','E','R','T','Y','U','I','O','P'],
        ['A','S','D','F','G','H','J','K','L'],
        ['Z','X','C','V','B','N','M'],
        ['1','2','3','4','5','6','7','8','9','0'],
        ['SPACE','DEL','OK']
    ],
    keyWidth: 0,
    keyHeight: 0,
    startX: 0,
    startY: 0,
    rowPadding: 4,
    keyPadding: 3
};

// --- Constants ---
var PADDLE_WIDTH_RATIO = 0.015;
var PADDLE_HEIGHT_RATIO = 0.15;
var BALL_RADIUS_RATIO = 0.008;
var PADDLE_MARGIN_RATIO = 0.035;
var WINNING_SCORE = 11;
var BEST_OF_SETS = 3;
var PADDLE_SPEED_RATIO = 0.009;

// --- Game State ---
var STATE = { MENU: 0, PLAYING: 1, COUNTDOWN: 2, SET_OVER: 3, MATCH_OVER: 4, PAUSED: 5, NAME_ENTRY: 6 };

var gameState = STATE.MENU;
var stateBeforePause = null;
var pauseResumeBtn = null;
var pauseMenuBtn = null;
var menuSelection = 0;
var menuOptions = isTouchDevice
    ? ['VS AI - Easy', 'VS AI - Medium', 'VS AI - Hard']
    : ['VS AI - Easy', 'VS AI - Medium', 'VS AI - Hard', 'Local 2 Player'];
var isVsAI = true;
var aiDifficulty = 1;

// Leaderboard
var LEADERBOARD_KEY = 'pongLeaderboard';
var nameEntryText = '';
var nameEntryCursorBlink = 0;
var matchWinnerScore = 0;
var matchWinnerLabel = '';

// Total points tracking per match (cumulative across all sets)
var p1TotalPoints = 0;
var p2TotalPoints = 0;

// Tournament
var p1Sets = 0;
var p2Sets = 0;
var currentSet = 1;

// Score
var p1Score = 0;
var p2Score = 0;

// Paddles
var paddle1 = null;
var paddle2 = null;

// Balls
var balls = [];

// Power-ups
var powerups = [];
var powerupTimer = 0;
var POWERUP_INTERVAL = 5500;
var POWERUP_TYPES = ['speed', 'bigPaddle', 'smallPaddle', 'multiBall', 'freeze'];
var POWERUP_COLORS = {
    speed: '#ff4444',
    bigPaddle: '#44ff44',
    smallPaddle: '#ff44ff',
    multiBall: '#44ffff',
    freeze: '#4488ff'
};
var POWERUP_LABELS = {
    speed: 'SPD',
    bigPaddle: 'BIG',
    smallPaddle: 'SML',
    multiBall: 'MUL',
    freeze: 'FRZ'
};
var POWERUP_NAMES = {
    speed: 'Speed Boost!',
    bigPaddle: 'Big Paddle!',
    smallPaddle: 'Small Paddle!',
    multiBall: 'Multi Ball!',
    freeze: 'Freeze!'
};

// Active effects
var p1Effects = {};
var p2Effects = {};

// Ability meters
var p1AbilityCharge = 0;
var p2AbilityCharge = 0;
var ABILITY_MAX = 100;
var ABILITY_CHARGE_PER_HIT = 20;
// Ability state: null = none, 'fireball' = next hit is fireball
var p1AbilityActive = null;
var p2AbilityActive = null;
var p1NextAbility = 'fireball';
var p2NextAbility = 'fireball';

// Freeze state (ms remaining)
var p1Frozen = 0;
var p2Frozen = 0;

// Particles
var particles = [];

// Screen flash
var screenFlash = 0;
var screenFlashColor = '#ffffff';

// Countdown timer
var countdownTimer = 0;
var countdownNum = 3;

// Notification text (e.g. "Speed Boost!")
var notifyText = '';
var notifyTimer = 0;
var notifyColor = '#ffffff';

// Timing
var lastTime = 0;

// Input
var keys = {};
window.addEventListener('keydown', function(e) {
    keys[e.code] = true;

    if (gameState === STATE.MENU) {
        ensureAudio();
        if (e.code === 'ArrowUp' || e.code === 'KeyW') {
            menuSelection = (menuSelection - 1 + menuOptions.length) % menuOptions.length;
            playMenuSelect();
        }
        if (e.code === 'ArrowDown' || e.code === 'KeyS') {
            menuSelection = (menuSelection + 1) % menuOptions.length;
            playMenuSelect();
        }
        if (e.code === 'Enter' || e.code === 'Space') {
            playMenuConfirm();
            startMatch(menuSelection);
        }
    } else if (gameState === STATE.PLAYING) {
        ensureAudio();
        if (e.code === 'Space' && p1AbilityCharge >= ABILITY_MAX && !p1AbilityActive) {
            activateAbility(1);
        }
        if (e.code === 'Enter' && !isVsAI && p2AbilityCharge >= ABILITY_MAX && !p2AbilityActive) {
            activateAbility(2);
        }
    } else if (gameState === STATE.SET_OVER) {
        if (e.code === 'Space' || e.code === 'Enter') {
            ensureAudio();
            startSet();
        }
    } else if (gameState === STATE.MATCH_OVER) {
        if (e.code === 'Space' || e.code === 'Enter') {
            ensureAudio();
            // Check if the winner qualifies for leaderboard
            if (isTopTenScore(matchWinnerScore)) {
                nameEntryText = '';
                nameEntryCursorBlink = 0;
                gameState = STATE.NAME_ENTRY;
            } else {
                gameState = STATE.MENU;
            }
        }
    } else if (gameState === STATE.NAME_ENTRY) {
        // Handle name entry input - letters, numbers, backspace, enter
        if (e.code === 'Enter') {
            var finalName = nameEntryText.trim() || 'PLAYER';
            addToLeaderboard(finalName, matchWinnerScore);
            gameState = STATE.MENU;
        } else if (e.code === 'Backspace') {
            nameEntryText = nameEntryText.slice(0, -1);
            e.preventDefault();
        } else if (e.key && e.key.length === 1 && nameEntryText.length < 12) {
            // Allow letters, numbers, spaces
            var ch = e.key;
            if (/[a-zA-Z0-9 ]/.test(ch)) {
                nameEntryText += ch.toUpperCase();
            }
        }
        // Prevent all default behavior during name entry
        e.preventDefault();
        return;
    }

    if (gameState !== STATE.NAME_ENTRY) {
        if (e.code === 'Escape') {
            if (gameState === STATE.PLAYING || gameState === STATE.COUNTDOWN || gameState === STATE.PAUSED) {
                window.location.href = '../../index.html';
            }
        }
        if (e.code === 'KeyP') {
            if (gameState === STATE.PLAYING || gameState === STATE.COUNTDOWN) {
                stateBeforePause = gameState;
                gameState = STATE.PAUSED;
            } else if (gameState === STATE.PAUSED) {
                gameState = stateBeforePause || STATE.PLAYING;
            }
        }
    }

    // Prevent scrolling
    if (['Space', 'ArrowUp', 'ArrowDown', 'KeyW', 'KeyS', 'Enter', 'Escape'].indexOf(e.code) !== -1) {
        e.preventDefault();
    }
});
window.addEventListener('keyup', function(e) {
    keys[e.code] = false;
});

// --- Touch Event Handlers ---
if (isTouchDevice) {
    // Prevent default on all touch events to avoid scrolling/zooming
    canvas.addEventListener('touchstart', function(e) { e.preventDefault(); }, { passive: false });
    canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
    canvas.addEventListener('touchend', function(e) { e.preventDefault(); }, { passive: false });

    // Helper: get touch position relative to canvas
    function getTouchPos(touch) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: (touch.clientX - rect.left) * (canvas.width / rect.width),
            y: (touch.clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    // Helper: check if point is inside ability button
    function isTouchInAbilityBtn(tx, ty) {
        var btnX = canvas.width - 80;
        var btnY = canvas.height - 80;
        var dx = tx - btnX;
        var dy = ty - btnY;
        return (dx * dx + dy * dy) <= (touchAbilityBtnRadius + 10) * (touchAbilityBtnRadius + 10);
    }

    // Helper: check if point is inside pause button
    function isTouchInPauseBtn(tx, ty) {
        var btnX = canvas.width - 40;
        var btnY = 40;
        var dx = tx - btnX;
        var dy = ty - btnY;
        return (dx * dx + dy * dy) <= (touchPauseBtnRadius + 10) * (touchPauseBtnRadius + 10);
    }

    // Helper: check if point is inside a rectangle
    function isTouchInRect(tx, ty, rx, ry, rw, rh) {
        return tx >= rx && tx <= rx + rw && ty >= ry && ty <= ry + rh;
    }

    // Helper: get keyboard key at touch position
    function getKeyboardKeyAt(tx, ty) {
        var kb = touchKeyboard;
        if (!kb.visible) return null;
        for (var row = 0; row < kb.keys.length; row++) {
            var rowKeys = kb.keys[row];
            var rowY = kb.startY + row * (kb.keyHeight + kb.rowPadding);
            // Center the row
            var totalRowWidth = 0;
            for (var k = 0; k < rowKeys.length; k++) {
                var keyLabel = rowKeys[k];
                var kw = kb.keyWidth;
                if (keyLabel === 'SPACE') kw = kb.keyWidth * 3 + kb.keyPadding * 2;
                else if (keyLabel === 'DEL' || keyLabel === 'OK') kw = kb.keyWidth * 1.8;
                totalRowWidth += kw + kb.keyPadding;
            }
            totalRowWidth -= kb.keyPadding;
            var rowX = kb.startX + (canvas.width * 0.8 - totalRowWidth) / 2;

            for (var k = 0; k < rowKeys.length; k++) {
                var keyLabel = rowKeys[k];
                var kw = kb.keyWidth;
                if (keyLabel === 'SPACE') kw = kb.keyWidth * 3 + kb.keyPadding * 2;
                else if (keyLabel === 'DEL' || keyLabel === 'OK') kw = kb.keyWidth * 1.8;

                if (tx >= rowX && tx <= rowX + kw && ty >= rowY && ty <= rowY + kb.keyHeight) {
                    return keyLabel;
                }
                rowX += kw + kb.keyPadding;
            }
        }
        return null;
    }

    canvas.addEventListener('touchstart', function(e) {
        ensureAudio();

        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];
            var pos = getTouchPos(touch);

            if (gameState === STATE.MENU) {
                // Tap on a menu option
                handleMenuTouch(pos.x, pos.y);
            } else if (gameState === STATE.PLAYING || gameState === STATE.COUNTDOWN) {
                // Check pause button first
                if (isTouchInPauseBtn(pos.x, pos.y)) {
                    stateBeforePause = gameState;
                    gameState = STATE.PAUSED;
                    continue;
                }

                // Check ability button (right side, only during PLAYING)
                if (gameState === STATE.PLAYING && p1AbilityCharge >= ABILITY_MAX && !p1AbilityActive && isTouchInAbilityBtn(pos.x, pos.y)) {
                    activateAbility(1);
                    continue;
                }

                // Left half of screen: paddle control
                if (pos.x < canvas.width / 2) {
                    touchPaddleId = touch.identifier;
                    touchPaddleActive = true;
                    if (paddle1) {
                        paddle1.y = pos.y - paddle1.height / 2;
                        paddle1.y = Math.max(0, Math.min(canvas.height - paddle1.height, paddle1.y));
                    }
                }
            } else if (gameState === STATE.PAUSED) {
                // Check pause screen buttons
                if (pauseResumeBtn && isTouchInRect(pos.x, pos.y, pauseResumeBtn.x, pauseResumeBtn.y, pauseResumeBtn.w, pauseResumeBtn.h)) {
                    gameState = stateBeforePause || STATE.PLAYING;
                } else if (pauseMenuBtn && isTouchInRect(pos.x, pos.y, pauseMenuBtn.x, pauseMenuBtn.y, pauseMenuBtn.w, pauseMenuBtn.h)) {
                    window.location.href = '../../index.html';
                }
            } else if (gameState === STATE.SET_OVER) {
                startSet();
            } else if (gameState === STATE.MATCH_OVER) {
                if (isTopTenScore(matchWinnerScore)) {
                    nameEntryText = '';
                    nameEntryCursorBlink = 0;
                    gameState = STATE.NAME_ENTRY;
                } else {
                    gameState = STATE.MENU;
                }
            } else if (gameState === STATE.NAME_ENTRY) {
                // Handle on-screen keyboard tap
                var keyHit = getKeyboardKeyAt(pos.x, pos.y);
                if (keyHit) {
                    if (keyHit === 'OK') {
                        var finalName = nameEntryText.trim() || 'PLAYER';
                        addToLeaderboard(finalName, matchWinnerScore);
                        gameState = STATE.MENU;
                    } else if (keyHit === 'DEL') {
                        nameEntryText = nameEntryText.slice(0, -1);
                    } else if (keyHit === 'SPACE') {
                        if (nameEntryText.length < 12) nameEntryText += ' ';
                    } else {
                        if (nameEntryText.length < 12) nameEntryText += keyHit;
                    }
                    playMenuSelect();
                }
            }
        }
    }, false);

    canvas.addEventListener('touchmove', function(e) {
        if (!touchPaddleActive) return;
        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];
            if (touch.identifier === touchPaddleId) {
                var pos = getTouchPos(touch);
                if (paddle1 && (gameState === STATE.PLAYING || gameState === STATE.COUNTDOWN)) {
                    paddle1.y = pos.y - paddle1.height / 2;
                    paddle1.y = Math.max(0, Math.min(canvas.height - paddle1.height, paddle1.y));
                }
            }
        }
    }, false);

    canvas.addEventListener('touchend', function(e) {
        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];
            if (touch.identifier === touchPaddleId) {
                touchPaddleActive = false;
                touchPaddleId = null;
            }
        }
    }, false);

    canvas.addEventListener('touchcancel', function(e) {
        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];
            if (touch.identifier === touchPaddleId) {
                touchPaddleActive = false;
                touchPaddleId = null;
            }
        }
    }, false);

    // Handle menu touch: determine which option was tapped
    function handleMenuTouch(tx, ty) {
        var cw = canvas.width;
        var ch = canvas.height;
        var optSize = Math.min(26, cw * 0.026);
        var spacing = optSize * 2.4;
        var startY = ch * 0.41;

        for (var i = 0; i < menuOptions.length; i++) {
            var yPos = startY + i * spacing;
            var boxW = cw * 0.5; // wider hit area for touch
            var boxH = spacing * 0.85;
            var boxX = cw / 2 - boxW / 2;
            var boxY = yPos - boxH / 2;

            if (tx >= boxX && tx <= boxX + boxW && ty >= boxY && ty <= boxY + boxH) {
                menuSelection = i;
                playMenuConfirm();
                startMatch(menuSelection);
                return;
            }
        }
    }
}

// --- Helper Functions ---
function pw() { return Math.max(canvas.width * PADDLE_WIDTH_RATIO, 10); }
function ph() { return canvas.height * PADDLE_HEIGHT_RATIO; }
function ballRadius() { return Math.max(Math.min(canvas.width, canvas.height) * BALL_RADIUS_RATIO, 5); }
function paddleMargin() { return canvas.width * PADDLE_MARGIN_RATIO; }
function paddleSpeed() { return canvas.height * PADDLE_SPEED_RATIO; }

function ballBaseSpeed() {
    return Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) * 0.0038;
}

function createBall(x, y, vx, vy) {
    var speed = ballBaseSpeed();
    if (vx === undefined) {
        var angle = (Math.random() * 0.7 - 0.35);
        var dir = Math.random() < 0.5 ? 1 : -1;
        vx = Math.cos(angle) * speed * dir;
        vy = Math.sin(angle) * speed;
    }
    return {
        x: x !== undefined ? x : canvas.width / 2,
        y: y !== undefined ? y : canvas.height / 2,
        vx: vx,
        vy: vy,
        radius: ballRadius(),
        baseSpeed: speed,
        fireball: false,
        trail: [],
        speedMultiplier: 1
    };
}

function createPaddle(side) {
    var x = side === 'left' ? paddleMargin() : canvas.width - paddleMargin() - pw();
    return {
        x: x,
        y: canvas.height / 2 - ph() / 2,
        width: pw(),
        height: ph(),
        baseHeight: ph(),
        glow: 0,
        side: side
    };
}

function spawnParticles(x, y, color, count, spread) {
    for (var i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * spread * 2,
            vy: (Math.random() - 0.5) * spread * 2,
            life: 1,
            decay: 0.015 + Math.random() * 0.025,
            color: color,
            size: 2 + Math.random() * 4
        });
    }
}

function showNotification(text, color) {
    notifyText = text;
    notifyColor = color || '#ffffff';
    notifyTimer = 1.5;
}

// --- Leaderboard Functions ---
function getLeaderboard() {
    try {
        var data = localStorage.getItem(LEADERBOARD_KEY);
        if (data) {
            var parsed = JSON.parse(data);
            if (Array.isArray(parsed)) return parsed;
        }
    } catch(e) {}
    return [];
}

function saveLeaderboard(board) {
    try {
        localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(board));
    } catch(e) {}
}

function isTopTenScore(score) {
    var board = getLeaderboard();
    if (board.length < 10) return true;
    return score > board[board.length - 1].score;
}

function addToLeaderboard(name, score) {
    var board = getLeaderboard();
    board.push({ name: name.toUpperCase(), score: score });
    board.sort(function(a, b) { return b.score - a.score; });
    if (board.length > 10) board = board.slice(0, 10);
    saveLeaderboard(board);
    return board;
}

function spawnPowerup() {
    var type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    var margin = canvas.width * 0.22;
    powerups.push({
        x: margin + Math.random() * (canvas.width - margin * 2),
        y: canvas.height * 0.12 + Math.random() * canvas.height * 0.76,
        type: type,
        radius: Math.max(16, Math.min(canvas.width, canvas.height) * 0.015),
        pulse: Math.random() * Math.PI * 2,
        life: 10000
    });
}

// --- Game Init ---
function startMatch(selection) {
    if (selection <= 2) {
        isVsAI = true;
        aiDifficulty = selection;
    } else {
        isVsAI = false;
    }
    p1Sets = 0;
    p2Sets = 0;
    p1TotalPoints = 0;
    p2TotalPoints = 0;
    currentSet = 1;
    p1AbilityCharge = 0;
    p2AbilityCharge = 0;
    p1NextAbility = 'fireball';
    p2NextAbility = 'fireball';
    startSet();
    backLink.style.display = 'none';
}

function startSet() {
    p1Score = 0;
    p2Score = 0;
    startNewPoint();
}

function startNewPoint() {
    paddle1 = createPaddle('left');
    paddle2 = createPaddle('right');
    balls = [createBall()];
    powerups = [];
    powerupTimer = 3500;
    p1Effects = {};
    p2Effects = {};
    p1Frozen = 0;
    p2Frozen = 0;
    particles = [];
    p1AbilityActive = null;
    p2AbilityActive = null;
    // Start countdown
    countdownTimer = 2.4;
    countdownNum = 3;
    gameState = STATE.COUNTDOWN;
}

function activateAbility(player) {
    playAbility();
    if (player === 1) {
        p1AbilityCharge = 0;
        p1AbilityActive = 'fireball';
        spawnParticles(paddle1.x + paddle1.width, paddle1.y + paddle1.height / 2,
            '#ff8800', 20, 6);
    } else {
        p2AbilityCharge = 0;
        p2AbilityActive = 'fireball';
        spawnParticles(paddle2.x, paddle2.y + paddle2.height / 2,
            '#ff8800', 20, 6);
    }
}

// --- AI ---
function updateAI(dt) {
    if (!isVsAI || p2Frozen > 0) return;

    // Find the most threatening ball
    var targetBall = null;
    var minTime = Infinity;
    for (var i = 0; i < balls.length; i++) {
        var b = balls[i];
        if (b.vx > 0) {
            var t = (paddle2.x - b.x) / (b.vx * b.speedMultiplier);
            if (t > 0 && t < minTime) {
                minTime = t;
                targetBall = b;
            }
        }
    }
    if (!targetBall) targetBall = balls[0];

    // Predict where ball will be when it reaches the paddle
    var predictY = targetBall.y;
    if (targetBall.vx > 0) {
        var timeToReach = (paddle2.x - targetBall.x) / (targetBall.vx * targetBall.speedMultiplier);
        if (timeToReach > 0) {
            predictY = targetBall.y + targetBall.vy * targetBall.speedMultiplier * timeToReach;
            // Bounce prediction (simple)
            var bounces = 0;
            while ((predictY < 0 || predictY > canvas.height) && bounces < 10) {
                if (predictY < 0) predictY = -predictY;
                if (predictY > canvas.height) predictY = 2 * canvas.height - predictY;
                bounces++;
            }
        }
    }

    // Difficulty settings
    var settings = [
        { reaction: 0.55, error: 70, speed: 0.55, abilityChance: 0.003 },   // Easy
        { reaction: 0.78, error: 25, speed: 0.82, abilityChance: 0.008 },   // Medium
        { reaction: 0.96, error: 6, speed: 1.0, abilityChance: 0.015 }      // Hard
    ];
    var s = settings[aiDifficulty];

    // Add some oscillating error so AI seems more human
    predictY += Math.sin(Date.now() * 0.002) * s.error;

    var paddleCenter = paddle2.y + paddle2.height / 2;
    var diff = predictY - paddleCenter;
    var moveSpeed = paddleSpeed() * s.speed * dt * 60;

    if (Math.random() < s.reaction) {
        if (diff > 4) paddle2.y += Math.min(moveSpeed, diff);
        else if (diff < -4) paddle2.y -= Math.min(moveSpeed, -diff);
    }

    // AI ability usage
    if (p2AbilityCharge >= ABILITY_MAX && !p2AbilityActive && Math.random() < s.abilityChance) {
        activateAbility(2);
    }

    // Clamp
    paddle2.y = Math.max(0, Math.min(canvas.height - paddle2.height, paddle2.y));
}

// --- Update ---
function update(dt) {
    // Countdown
    if (gameState === STATE.COUNTDOWN) {
        countdownTimer -= dt;
        countdownNum = Math.ceil(countdownTimer / 0.8);
        if (countdownNum < 1) countdownNum = 1;
        if (countdownTimer <= 0) {
            gameState = STATE.PLAYING;
        }
        // Still update particles during countdown
        updateParticles(dt);
        return;
    }

    if (gameState !== STATE.PLAYING) return;

    var moveSpeed = paddleSpeed() * dt * 60;

    // Player 1 movement
    if (p1Frozen <= 0) {
        if (keys['KeyW']) paddle1.y -= moveSpeed;
        if (keys['KeyS']) paddle1.y += moveSpeed;
    }
    p1Frozen = Math.max(0, p1Frozen - dt * 1000);

    // Player 2 / AI movement
    if (p2Frozen <= 0) {
        if (isVsAI) {
            updateAI(dt);
        } else {
            if (keys['ArrowUp']) paddle2.y -= moveSpeed;
            if (keys['ArrowDown']) paddle2.y += moveSpeed;
        }
    }
    p2Frozen = Math.max(0, p2Frozen - dt * 1000);

    // Clamp paddles
    paddle1.y = Math.max(0, Math.min(canvas.height - paddle1.height, paddle1.y));
    paddle2.y = Math.max(0, Math.min(canvas.height - paddle2.height, paddle2.y));

    // Update paddle positions for window resize
    paddle1.x = paddleMargin();
    paddle1.width = pw();
    paddle2.x = canvas.width - paddleMargin() - pw();
    paddle2.width = pw();

    // Effect timers
    updateEffects(p1Effects, paddle1, dt);
    updateEffects(p2Effects, paddle2, dt);

    // Apply paddle size effects
    paddle1.height = paddle1.baseHeight;
    paddle2.height = paddle2.baseHeight;
    if (p1Effects.bigPaddle) paddle1.height = paddle1.baseHeight * 1.6;
    if (p1Effects.smallPaddle) paddle1.height = paddle1.baseHeight * 0.6;
    if (p2Effects.bigPaddle) paddle2.height = paddle2.baseHeight * 1.6;
    if (p2Effects.smallPaddle) paddle2.height = paddle2.baseHeight * 0.6;

    // Power-up spawn timer
    powerupTimer -= dt * 1000;
    if (powerupTimer <= 0) {
        if (powerups.length < 3) spawnPowerup();
        powerupTimer = POWERUP_INTERVAL + Math.random() * 3000;
    }

    // Update power-ups
    for (var i = powerups.length - 1; i >= 0; i--) {
        powerups[i].pulse += dt * 3;
        powerups[i].life -= dt * 1000;
        if (powerups[i].life <= 0) {
            powerups.splice(i, 1);
        }
    }

    // Update balls
    var scored = 0; // 0 = none, 1 = P1 scored, 2 = P2 scored
    for (var bi = balls.length - 1; bi >= 0; bi--) {
        var ball = balls[bi];

        var effVx = ball.vx * ball.speedMultiplier;
        var effVy = ball.vy * ball.speedMultiplier;
        ball.x += effVx * dt * 60;
        ball.y += effVy * dt * 60;
        ball.radius = ballRadius();

        // Trail
        ball.trail.push({ x: ball.x, y: ball.y, life: 1 });
        if (ball.trail.length > 18) ball.trail.shift();
        for (var ti = 0; ti < ball.trail.length; ti++) ball.trail[ti].life -= dt * 3.5;

        // Wall bounce (top/bottom)
        if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy = Math.abs(ball.vy);
            playWallHit();
            spawnParticles(ball.x, 0, '#4466cc', 4, 2);
        }
        if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy = -Math.abs(ball.vy);
            playWallHit();
            spawnParticles(ball.x, canvas.height, '#4466cc', 4, 2);
        }

        // --- Paddle 1 collision ---
        if (ball.vx < 0 &&
            ball.x - ball.radius <= paddle1.x + paddle1.width &&
            ball.x + ball.radius >= paddle1.x &&
            ball.y + ball.radius >= paddle1.y &&
            ball.y - ball.radius <= paddle1.y + paddle1.height) {

            ball.x = paddle1.x + paddle1.width + ball.radius;
            var hitPos1 = (ball.y - paddle1.y) / paddle1.height - 0.5;
            var angle1 = hitPos1 * Math.PI * 0.38;
            var speed1 = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) * 1.015;
            ball.vx = Math.abs(Math.cos(angle1) * speed1);
            ball.vy = Math.sin(angle1) * speed1;

            // Ability effects
            if (p1AbilityActive === 'fireball') {
                ball.fireball = true;
                ball.speedMultiplier = 2.0;
                p1AbilityActive = null;
                spawnParticles(ball.x, ball.y, '#ff4400', 25, 8);
                showNotification('FIREBALL!', '#ff6600');
            } else {
                ball.fireball = false;
                ball.speedMultiplier = Math.max(1, ball.speedMultiplier * 0.95);
            }

            p1AbilityCharge = Math.min(ABILITY_MAX, p1AbilityCharge + ABILITY_CHARGE_PER_HIT);
            paddle1.glow = 1;
            playHit();
            spawnParticles(ball.x, ball.y, '#44ff88', 8, 4);
        }

        // --- Paddle 2 collision ---
        if (ball.vx > 0 &&
            ball.x + ball.radius >= paddle2.x &&
            ball.x - ball.radius <= paddle2.x + paddle2.width &&
            ball.y + ball.radius >= paddle2.y &&
            ball.y - ball.radius <= paddle2.y + paddle2.height) {

            ball.x = paddle2.x - ball.radius;
            var hitPos2 = (ball.y - paddle2.y) / paddle2.height - 0.5;
            var angle2 = hitPos2 * Math.PI * 0.38;
            var speed2 = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) * 1.015;
            ball.vx = -Math.abs(Math.cos(angle2) * speed2);
            ball.vy = Math.sin(angle2) * speed2;

            if (p2AbilityActive === 'fireball') {
                ball.fireball = true;
                ball.speedMultiplier = 2.0;
                p2AbilityActive = null;
                spawnParticles(ball.x, ball.y, '#ff4400', 25, 8);
                showNotification('FIREBALL!', '#ff6600');
            } else {
                ball.fireball = false;
                ball.speedMultiplier = Math.max(1, ball.speedMultiplier * 0.95);
            }

            p2AbilityCharge = Math.min(ABILITY_MAX, p2AbilityCharge + ABILITY_CHARGE_PER_HIT);
            paddle2.glow = 1;
            playHit();
            spawnParticles(ball.x, ball.y, '#ff44aa', 8, 4);
        }

        // --- Power-up collision ---
        for (var pi = powerups.length - 1; pi >= 0; pi--) {
            var pu = powerups[pi];
            var dx = ball.x - pu.x;
            var dy = ball.y - pu.y;
            if (Math.sqrt(dx * dx + dy * dy) < ball.radius + pu.radius) {
                // lastHitBy: if ball is heading right (vx>0), P1 hit it last; if heading left, P2 hit it last
                var lastHitBy = ball.vx > 0 ? 1 : 2;
                applyPowerup(pu.type, lastHitBy);
                spawnParticles(pu.x, pu.y, POWERUP_COLORS[pu.type], 18, 6);
                playPowerup();
                showNotification(POWERUP_NAMES[pu.type], POWERUP_COLORS[pu.type]);
                powerups.splice(pi, 1);
            }
        }

        // --- Score detection ---
        if (ball.x + ball.radius < -10) {
            // P2 scores (ball went past P1's side)
            if (balls.length > 1) {
                balls.splice(bi, 1);
            } else {
                scored = 2;
                screenFlash = 0.4;
                screenFlashColor = '#ff44aa';
                spawnParticles(0, ball.y, '#ff44aa', 40, 10);
                playScore();
            }
        }
        if (ball.x - ball.radius > canvas.width + 10) {
            // P1 scores (ball went past P2's side)
            if (balls.length > 1) {
                balls.splice(bi, 1);
            } else {
                scored = 1;
                screenFlash = 0.4;
                screenFlashColor = '#44ff88';
                spawnParticles(canvas.width, ball.y, '#44ff88', 40, 10);
                playScore();
            }
        }

        // Speed cap
        var maxSpeed = ball.baseSpeed * 2.5;
        var currentSpd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (currentSpd > maxSpeed) {
            ball.vx = (ball.vx / currentSpd) * maxSpeed;
            ball.vy = (ball.vy / currentSpd) * maxSpeed;
        }
    }

    // After scoring
    if (scored) {
        if (scored === 1) { p1Score++; p1TotalPoints++; }
        else { p2Score++; p2TotalPoints++; }

        // Check set win (first to 11, win by 2)
        if ((p1Score >= WINNING_SCORE || p2Score >= WINNING_SCORE) &&
            Math.abs(p1Score - p2Score) >= 2) {
            if (p1Score > p2Score) p1Sets++;
            else p2Sets++;

            // Check match win
            var setsToWin = Math.ceil(BEST_OF_SETS / 2);
            if (p1Sets >= setsToWin || p2Sets >= setsToWin) {
                // Determine winner's total score
                if (p1Sets > p2Sets) {
                    matchWinnerScore = p1TotalPoints;
                    matchWinnerLabel = 'Player 1';
                } else {
                    matchWinnerScore = p2TotalPoints;
                    matchWinnerLabel = isVsAI ? 'AI' : 'Player 2';
                }
                gameState = STATE.MATCH_OVER;
                playGameWin();
            } else {
                currentSet++;
                gameState = STATE.SET_OVER;
            }
        } else {
            // Next point after a brief pause
            startNewPoint();
        }
    }

    // Update particles
    updateParticles(dt);

    // Paddle glow decay
    if (paddle1) paddle1.glow = Math.max(0, paddle1.glow - dt * 3);
    if (paddle2) paddle2.glow = Math.max(0, paddle2.glow - dt * 3);

    // Screen flash decay
    screenFlash = Math.max(0, screenFlash - dt * 2.5);

    // Notification decay
    if (notifyTimer > 0) notifyTimer -= dt;
}

function updateEffects(effects, paddle, dt) {
    for (var key in effects) {
        if (effects.hasOwnProperty(key)) {
            effects[key] -= dt * 1000;
            if (effects[key] <= 0) {
                delete effects[key];
            }
        }
    }
}

function updateParticles(dt) {
    for (var i = particles.length - 1; i >= 0; i--) {
        var p = particles[i];
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function applyPowerup(type, lastHitBy) {
    var duration = 6000;
    switch(type) {
        case 'speed':
            for (var i = 0; i < balls.length; i++) {
                balls[i].speedMultiplier = 1.6;
            }
            // Use effect timer to auto-reset
            if (lastHitBy === 1) p1Effects.speed = duration;
            else p2Effects.speed = duration;
            setTimeout(function() {
                for (var j = 0; j < balls.length; j++) {
                    if (balls[j].speedMultiplier > 1) balls[j].speedMultiplier = 1;
                }
            }, duration);
            break;
        case 'bigPaddle':
            if (lastHitBy === 1) p1Effects.bigPaddle = duration;
            else p2Effects.bigPaddle = duration;
            break;
        case 'smallPaddle':
            // Shrinks opponent
            if (lastHitBy === 1) p2Effects.smallPaddle = duration;
            else p1Effects.smallPaddle = duration;
            break;
        case 'multiBall':
            if (balls.length < 4 && balls.length > 0) {
                var ref = balls[0];
                var nb = createBall(ref.x, ref.y, -ref.vx * 0.9, -ref.vy + (Math.random() - 0.5) * 2);
                balls.push(nb);
            }
            break;
        case 'freeze':
            playFreeze();
            if (lastHitBy === 1) p2Frozen = 2000;
            else p1Frozen = 2000;
            break;
    }
}

// --- Drawing ---
function drawNeonRect(x, y, w, h, color, glowAmt) {
    ctx.save();
    ctx.shadowColor = color;
    ctx.shadowBlur = 12 + (glowAmt || 0) * 25;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
    // Extra glow layer
    ctx.globalAlpha = 0.4;
    ctx.shadowBlur = 25 + (glowAmt || 0) * 15;
    ctx.fillRect(x, y, w, h);
    ctx.restore();
}

function drawNeonCircle(x, y, r, color, glowAmt) {
    ctx.save();
    ctx.shadowColor = color;
    ctx.shadowBlur = 10 + (glowAmt || 0) * 20;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

function drawNeonText(text, x, y, size, color, align) {
    align = align || 'center';
    ctx.save();
    ctx.shadowColor = color;
    ctx.shadowBlur = 15;
    ctx.fillStyle = color;
    ctx.font = 'bold ' + size + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
    // Second pass for extra glow
    ctx.shadowBlur = 6;
    ctx.fillText(text, x, y);
    ctx.restore();
}

function drawBackground() {
    // Dark gradient background
    var grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#080818');
    grad.addColorStop(0.5, '#0c0c22');
    grad.addColorStop(1, '#080818');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Subtle grid
    ctx.strokeStyle = 'rgba(35, 35, 70, 0.25)';
    ctx.lineWidth = 1;
    var gridSize = 50;
    for (var gx = 0; gx < canvas.width; gx += gridSize) {
        ctx.beginPath();
        ctx.moveTo(gx, 0);
        ctx.lineTo(gx, canvas.height);
        ctx.stroke();
    }
    for (var gy = 0; gy < canvas.height; gy += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, gy);
        ctx.lineTo(canvas.width, gy);
        ctx.stroke();
    }

    // Center dashed line
    ctx.save();
    ctx.setLineDash([12, 12]);
    ctx.strokeStyle = 'rgba(90, 90, 180, 0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();
    ctx.restore();

    // Center circle
    ctx.strokeStyle = 'rgba(90, 90, 180, 0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) * 0.08, 0, Math.PI * 2);
    ctx.stroke();
}

function drawGame() {
    drawBackground();

    var cw = canvas.width;
    var ch = canvas.height;

    // Screen flash
    if (screenFlash > 0) {
        ctx.save();
        ctx.globalAlpha = screenFlash * 0.35;
        ctx.fillStyle = screenFlashColor;
        ctx.fillRect(0, 0, cw, ch);
        ctx.restore();
    }

    // Freeze overlays
    if (p1Frozen > 0) {
        ctx.save();
        ctx.globalAlpha = 0.08 + Math.sin(Date.now() * 0.008) * 0.03;
        ctx.fillStyle = '#3366ff';
        ctx.fillRect(0, 0, cw / 2, ch);
        ctx.restore();
    }
    if (p2Frozen > 0) {
        ctx.save();
        ctx.globalAlpha = 0.08 + Math.sin(Date.now() * 0.008) * 0.03;
        ctx.fillStyle = '#3366ff';
        ctx.fillRect(cw / 2, 0, cw / 2, ch);
        ctx.restore();
    }

    // --- Draw paddles ---
    if (paddle1) {
        var p1Color = p1Frozen > 0 ? '#4488ff' : '#44ff88';
        drawNeonRect(paddle1.x, paddle1.y, paddle1.width, paddle1.height, p1Color, paddle1.glow);

        // Ability active border
        if (p1AbilityActive) {
            var abCol1 = p1AbilityActive === 'fireball' ? '#ff8800' : '#aa44ff';
            ctx.save();
            ctx.shadowColor = abCol1;
            ctx.shadowBlur = 15 + Math.sin(Date.now() * 0.01) * 5;
            ctx.strokeStyle = abCol1;
            ctx.lineWidth = 3;
            ctx.strokeRect(paddle1.x - 4, paddle1.y - 4, paddle1.width + 8, paddle1.height + 8);
            ctx.restore();
        }
    }

    if (paddle2) {
        var p2Color = p2Frozen > 0 ? '#4488ff' : '#ff44aa';
        drawNeonRect(paddle2.x, paddle2.y, paddle2.width, paddle2.height, p2Color, paddle2.glow);

        if (p2AbilityActive) {
            var abCol2 = p2AbilityActive === 'fireball' ? '#ff8800' : '#aa44ff';
            ctx.save();
            ctx.shadowColor = abCol2;
            ctx.shadowBlur = 15 + Math.sin(Date.now() * 0.01) * 5;
            ctx.strokeStyle = abCol2;
            ctx.lineWidth = 3;
            ctx.strokeRect(paddle2.x - 4, paddle2.y - 4, paddle2.width + 8, paddle2.height + 8);
            ctx.restore();
        }
    }

    // --- Draw ball trails & balls ---
    for (var bi = 0; bi < balls.length; bi++) {
        var ball = balls[bi];

        // Trail
        for (var ti = 0; ti < ball.trail.length; ti++) {
            var t = ball.trail[ti];
            if (t.life > 0) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, t.life * 0.45);
                var trailR = ball.radius * Math.max(0.2, t.life) * 0.8;
                if (ball.fireball) {
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 8;
                } else {
                    ctx.fillStyle = '#8888dd';
                    ctx.shadowColor = '#6666bb';
                    ctx.shadowBlur = 4;
                }
                ctx.beginPath();
                ctx.arc(t.x, t.y, trailR, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Ball itself
        var ballCol = '#ffffff';
        var ballGlow = 0.3;
        if (ball.fireball) {
            ballCol = '#ff7722';
            ballGlow = 1.0;
        }
        drawNeonCircle(ball.x, ball.y, ball.radius, ballCol, ballGlow);

        // Fireball trailing particles
        if (ball.fireball && Math.random() < 0.6) {
            spawnParticles(ball.x - ball.vx * 0.3, ball.y - ball.vy * 0.3, '#ff4400', 1, 2);
        }
    }

    // --- Draw powerups ---
    for (var pi = 0; pi < powerups.length; pi++) {
        var pu = powerups[pi];
        var pulse = Math.sin(pu.pulse) * 0.25 + 0.75;
        var r = pu.radius * pulse;
        var col = POWERUP_COLORS[pu.type];

        // Fading warning when about to despawn
        var fadeAlpha = pu.life < 2000 ? (pu.life / 2000) : 1;
        var blinkAlpha = pu.life < 2000 ? (Math.sin(Date.now() * 0.015) > 0 ? 1 : 0.3) : 1;
        ctx.save();
        ctx.globalAlpha = fadeAlpha * blinkAlpha;

        // Outer glow ring
        ctx.shadowColor = col;
        ctx.shadowBlur = 18;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, r + 5, 0, Math.PI * 2);
        ctx.stroke();

        // Inner filled circle
        ctx.fillStyle = col;
        ctx.globalAlpha = fadeAlpha * blinkAlpha * 0.35;
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Label
        ctx.globalAlpha = fadeAlpha * blinkAlpha;
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold ' + Math.max(9, r * 0.55) + 'px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(POWERUP_LABELS[pu.type], pu.x, pu.y);
        ctx.restore();
    }

    // --- Draw particles ---
    for (var parti = 0; parti < particles.length; parti++) {
        var p = particles[parti];
        ctx.save();
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 3;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size * p.life, p.size * p.life);
        ctx.restore();
    }

    // --- Notification text ---
    if (notifyTimer > 0) {
        var notAlpha = Math.min(1, notifyTimer * 2);
        var notScale = 1 + (1.5 - notifyTimer) * 0.1;
        drawNeonText(notifyText, cw / 2, ch * 0.38, Math.floor(24 * notScale), notifyColor);
    }

    // --- HUD ---
    drawHUD();

    // --- Freeze text ---
    if (p1Frozen > 0) drawNeonText('FROZEN!', cw * 0.25, ch / 2, 30, '#4488ff');
    if (p2Frozen > 0) drawNeonText('FROZEN!', cw * 0.75, ch / 2, 30, '#4488ff');
}

function drawHUD() {
    var cw = canvas.width;
    var ch = canvas.height;

    // Score
    var scoreSize = Math.min(52, cw * 0.04);
    drawNeonText(p1Score.toString(), cw * 0.35, 50, scoreSize, '#44ff88');
    drawNeonText(p2Score.toString(), cw * 0.65, 50, scoreSize, '#ff44aa');
    drawNeonText('-', cw * 0.5, 50, scoreSize * 0.7, '#555588');

    // Title mini
    ctx.fillStyle = '#333366';
    ctx.font = Math.min(12, cw * 0.012) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('PONG CHAMPIONSHIP', cw / 2, 18);

    // Set score
    var setStr = 'Sets: ' + p1Sets + ' - ' + p2Sets + '  |  Set ' + currentSet + ' of ' + BEST_OF_SETS;
    ctx.fillStyle = '#7777aa';
    ctx.font = Math.min(15, cw * 0.014) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(setStr, cw / 2, 50 + scoreSize * 0.7);

    // Win condition reminder
    if (p1Score >= WINNING_SCORE - 2 || p2Score >= WINNING_SCORE - 2) {
        if (Math.abs(p1Score - p2Score) < 2 && p1Score >= WINNING_SCORE - 1) {
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold ' + Math.min(14, cw * 0.013) + 'px "Segoe UI", Arial, sans-serif';
            ctx.fillText('DEUCE - Win by 2!', cw / 2, 50 + scoreSize * 0.7 + 20);
        }
    }

    // Player labels
    ctx.font = Math.min(13, cw * 0.012) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#44ff88';
    ctx.fillText('P1 (W/S)', 12, ch - 12);
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ff44aa';
    ctx.fillText(isVsAI ? 'AI (' + ['Easy','Med','Hard'][aiDifficulty] + ')' : 'P2 (\u2191/\u2193)', cw - 12, ch - 12);

    // Ability meters
    var meterW = Math.min(120, cw * 0.1);
    drawAbilityMeter(cw * 0.15, ch - 55, meterW, p1AbilityCharge, '#44ff88', p1AbilityActive, p1NextAbility);
    drawAbilityMeter(cw * 0.85, ch - 55, meterW, p2AbilityCharge, '#ff44aa', p2AbilityActive, p2NextAbility);

    // Ability key hints
    ctx.font = Math.min(11, cw * 0.01) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#666688';
    ctx.fillText('[SPACE] Fireball', cw * 0.15, ch - 30);
    if (!isVsAI) {
        ctx.fillText('[ENTER] Fireball', cw * 0.85, ch - 30);
    }

    // Active effects indicators
    drawEffectIcons(12, 120, p1Effects, '#44ff88');
    drawEffectIcons(cw - 12, 120, p2Effects, '#ff44aa', 'right');
}

function drawAbilityMeter(cx, y, w, charge, color, activeAbility, nextAbility) {
    var h = 10;
    var x = cx - w / 2;

    // Background
    ctx.fillStyle = '#14142a';
    ctx.fillRect(x, y, w, h);

    // Fill
    var fillW = (charge / ABILITY_MAX) * w;
    var full = charge >= ABILITY_MAX;
    var fillColor = full ? '#ffaa00' : color;

    ctx.save();
    ctx.shadowColor = fillColor;
    ctx.shadowBlur = full ? 10 : 4;
    ctx.fillStyle = fillColor;
    ctx.fillRect(x, y, fillW, h);
    ctx.restore();

    // Border
    ctx.strokeStyle = color + '44';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);

    // Labels
    if (activeAbility) {
        var abLabel = 'FIREBALL READY!';
        var abColor = '#ff8800';
        ctx.fillStyle = abColor;
        ctx.font = 'bold 11px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'center';
        // Pulsing text
        ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.008) * 0.4;
        ctx.fillText(abLabel, cx, y - 6);
        ctx.globalAlpha = 1;
    } else if (full) {
        ctx.fillStyle = '#ffaa00';
        ctx.font = 'bold 11px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('READY!', cx, y - 6);
    }
}

function drawEffectIcons(x, y, effects, color, align) {
    align = align || 'left';
    var yOff = 0;
    ctx.font = 'bold 11px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = align;
    for (var key in effects) {
        if (effects.hasOwnProperty(key)) {
            var remaining = Math.ceil(effects[key] / 1000);
            ctx.fillStyle = POWERUP_COLORS[key] || color;
            var label = (POWERUP_LABELS[key] || key) + ' ' + remaining + 's';
            ctx.fillText(label, x, y + yOff);
            yOff += 18;
        }
    }
}

function drawMenu() {
    drawBackground();

    var cw = canvas.width;
    var ch = canvas.height;
    var now = Date.now() * 0.001;

    // Title - "PONG" in cyan, "CHAMPIONSHIP" in purple
    var titleSize = Math.min(cw * 0.065, 68);
    // Subtle animation
    var titleWobble = Math.sin(now * 1.5) * 2;
    drawNeonText('PONG', cw / 2, ch * 0.17 + titleWobble, titleSize, '#44ccff');
    drawNeonText('CHAMPIONSHIP', cw / 2, ch * 0.17 + titleSize * 0.85 + titleWobble, titleSize * 0.58, '#bb55ff');

    // Subtitle
    ctx.fillStyle = '#555588';
    ctx.font = Math.min(16, cw * 0.016) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText("Jake's Arcade", cw / 2, ch * 0.17 + titleSize * 1.55);

    // Decorative horizontal line
    var lineGrad = ctx.createLinearGradient(cw * 0.25, 0, cw * 0.75, 0);
    lineGrad.addColorStop(0, 'rgba(68, 204, 255, 0)');
    lineGrad.addColorStop(0.5, 'rgba(68, 204, 255, 0.3)');
    lineGrad.addColorStop(1, 'rgba(187, 85, 255, 0)');
    ctx.strokeStyle = lineGrad;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cw * 0.25, ch * 0.34);
    ctx.lineTo(cw * 0.75, ch * 0.34);
    ctx.stroke();

    // Menu options
    var startY = ch * 0.41;
    var optSize = Math.min(26, cw * 0.026);
    var spacing = optSize * 2.4;

    for (var i = 0; i < menuOptions.length; i++) {
        var selected = i === menuSelection;
        var yPos = startY + i * spacing;
        var color = selected ? '#44ffcc' : '#555580';
        var size = selected ? optSize * 1.12 : optSize;

        if (selected) {
            // Highlight box
            var boxW = cw * 0.32;
            ctx.save();
            ctx.fillStyle = 'rgba(68, 255, 204, 0.05)';
            ctx.fillRect(cw / 2 - boxW / 2, yPos - size * 0.8, boxW, size * 1.6);
            ctx.strokeStyle = 'rgba(68, 255, 204, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(cw / 2 - boxW / 2, yPos - size * 0.8, boxW, size * 1.6);
            ctx.restore();

            // Arrow
            drawNeonText('\u25b6', cw / 2 - boxW / 2 + 15, yPos, size * 0.6, '#44ffcc');
        }

        drawNeonText(menuOptions[i], cw / 2, yPos, size, color);
    }

    // --- Menu navigation hint (above controls panel) ---
    var navHintSize = Math.max(14, Math.min(16, cw * 0.015));
    ctx.fillStyle = '#666688';
    ctx.font = navHintSize + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    if (isTouchDevice) {
        ctx.fillText('Tap a mode to select  |  Tap START to begin', cw / 2, ch * 0.68);
    } else {
        ctx.fillText('W/S or \u2191/\u2193 to select  |  SPACE or ENTER to start', cw / 2, ch * 0.68);
    }
    ctx.fillText('Best of 3 sets  |  First to 11 (win by 2)', cw / 2, ch * 0.68 + navHintSize * 1.5);

    // --- CONTROLS PANEL ---
    var panelW = Math.min(500, cw * 0.55);
    var numControls = isTouchDevice ? 3 : 6;
    var panelH = 60 + numControls * 26;
    var panelX = cw / 2 - panelW / 2;
    var panelY = ch * 0.74;
    var lineH = 26;
    var keyFontSize = Math.max(16, Math.min(18, cw * 0.017));
    var descFontSize = Math.max(14, Math.min(16, cw * 0.015));
    var headingFontSize = Math.max(18, Math.min(22, cw * 0.02));

    // Semi-transparent dark panel background
    ctx.save();
    ctx.fillStyle = 'rgba(8, 8, 24, 0.82)';
    ctx.strokeStyle = 'rgba(100, 100, 180, 0.3)';
    ctx.lineWidth = 1.5;
    // Rounded rectangle
    var cornerR = 10;
    ctx.beginPath();
    ctx.moveTo(panelX + cornerR, panelY);
    ctx.lineTo(panelX + panelW - cornerR, panelY);
    ctx.arcTo(panelX + panelW, panelY, panelX + panelW, panelY + cornerR, cornerR);
    ctx.lineTo(panelX + panelW, panelY + panelH - cornerR);
    ctx.arcTo(panelX + panelW, panelY + panelH, panelX + panelW - cornerR, panelY + panelH, cornerR);
    ctx.lineTo(panelX + cornerR, panelY + panelH);
    ctx.arcTo(panelX, panelY + panelH, panelX, panelY + panelH - cornerR, cornerR);
    ctx.lineTo(panelX, panelY + cornerR);
    ctx.arcTo(panelX, panelY, panelX + cornerR, panelY, cornerR);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // "CONTROLS" heading with gold neon style
    var headY = panelY + 28;
    drawNeonText('CONTROLS', cw / 2, headY, headingFontSize, '#FFD700');

    // Decorative line under heading
    ctx.save();
    var lineGrad2 = ctx.createLinearGradient(panelX + 30, 0, panelX + panelW - 30, 0);
    lineGrad2.addColorStop(0, 'rgba(255, 215, 0, 0)');
    lineGrad2.addColorStop(0.5, 'rgba(255, 215, 0, 0.45)');
    lineGrad2.addColorStop(1, 'rgba(255, 215, 0, 0)');
    ctx.strokeStyle = lineGrad2;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(panelX + 30, headY + 14);
    ctx.lineTo(panelX + panelW - 30, headY + 14);
    ctx.stroke();
    ctx.restore();

    // Control lines - two columns (key | description)
    var controlStartY = headY + 32;
    var colKeyX = cw / 2 - panelW * 0.2;   // keys column (right-aligned)
    var colDescX = cw / 2 - panelW * 0.12;  // description column (left-aligned)

    var controls;
    if (isTouchDevice) {
        controls = [
            { key: 'Drag', desc: 'Move paddle up / down', keyCol: '#FFD700', descCol: '#44ff88' },
            { key: 'Tap ability', desc: 'Use special ability', keyCol: '#FFD700', descCol: '#44ff88' },
            { key: '\u2759\u2759', desc: 'Pause game', keyCol: '#FFD700', descCol: '#ccccdd' }
        ];
    } else {
        controls = [
            { key: 'W / S', desc: 'Move paddle (Player 1)', keyCol: '#FFD700', descCol: '#44ff88' },
            { key: '\u2191 / \u2193', desc: 'Move paddle (Player 2)', keyCol: '#FFD700', descCol: '#ff44aa' },
            { key: 'SPACE', desc: 'Special ability (Player 1)', keyCol: '#FFD700', descCol: '#44ff88' },
            { key: 'ENTER', desc: 'Special ability (Player 2)', keyCol: '#FFD700', descCol: '#ff44aa' },
            { key: 'P', desc: 'Pause game', keyCol: '#FFD700', descCol: '#ccccdd' },
            { key: 'ESC', desc: 'Main menu', keyCol: '#FFD700', descCol: '#ccccdd' }
        ];
    }

    for (var ci = 0; ci < controls.length; ci++) {
        var cy = controlStartY + ci * lineH;
        var ctrl = controls[ci];

        // Key label (gold, bold)
        ctx.save();
        ctx.font = 'bold ' + keyFontSize + 'px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = ctrl.keyCol;
        ctx.shadowColor = ctrl.keyCol;
        ctx.shadowBlur = 6;
        ctx.fillText(ctrl.key, colKeyX, cy);
        ctx.restore();

        // Separator dash
        ctx.save();
        ctx.font = descFontSize + 'px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#555577';
        ctx.fillText('\u2014', colKeyX + (colDescX - colKeyX) / 2, cy);
        ctx.restore();

        // Description (colour-coded)
        ctx.save();
        ctx.font = descFontSize + 'px "Segoe UI", Arial, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = ctrl.descCol;
        ctx.fillText(ctrl.desc, colDescX, cy);
        ctx.restore();
    }

    // Decorative animated ball
    var ballX = cw / 2 + Math.sin(now * 2) * cw * 0.12;
    var ballY = ch * 0.335 + Math.cos(now * 2.5) * 4;
    drawNeonCircle(ballX, ballY, 5, '#ffffff', 0.5);

    // Small bouncing paddles on sides
    var padH = 30;
    var padW = 6;
    var padY1 = ch * 0.5 + Math.sin(now * 1.3) * 40;
    var padY2 = ch * 0.5 + Math.sin(now * 1.3 + 1) * 40;
    drawNeonRect(20, padY1, padW, padH, '#44ff8855', 0);
    drawNeonRect(cw - 20 - padW, padY2, padW, padH, '#ff44aa55', 0);

    // --- TOP 5 LEADERBOARD on menu ---
    var menuBoard = getLeaderboard();
    if (menuBoard.length > 0) {
        var lbPanelW = Math.min(220, cw * 0.2);
        var lbPanelH = Math.min(200, ch * 0.3);
        var lbPanelX = cw - lbPanelW - 30;
        var lbPanelY = ch * 0.35;

        // Panel background
        ctx.save();
        ctx.fillStyle = 'rgba(8, 8, 30, 0.8)';
        ctx.strokeStyle = 'rgba(100, 100, 200, 0.3)';
        ctx.lineWidth = 1;
        var lbCR = 8;
        ctx.beginPath();
        ctx.moveTo(lbPanelX + lbCR, lbPanelY);
        ctx.lineTo(lbPanelX + lbPanelW - lbCR, lbPanelY);
        ctx.arcTo(lbPanelX + lbPanelW, lbPanelY, lbPanelX + lbPanelW, lbPanelY + lbCR, lbCR);
        ctx.lineTo(lbPanelX + lbPanelW, lbPanelY + lbPanelH - lbCR);
        ctx.arcTo(lbPanelX + lbPanelW, lbPanelY + lbPanelH, lbPanelX + lbPanelW - lbCR, lbPanelY + lbPanelH, lbCR);
        ctx.lineTo(lbPanelX + lbCR, lbPanelY + lbPanelH);
        ctx.arcTo(lbPanelX, lbPanelY + lbPanelH, lbPanelX, lbPanelY + lbPanelH - lbCR, lbCR);
        ctx.lineTo(lbPanelX, lbPanelY + lbCR);
        ctx.arcTo(lbPanelX, lbPanelY, lbPanelX + lbCR, lbPanelY, lbCR);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // Title
        var lbTitleSize = Math.min(16, cw * 0.015);
        drawNeonText('TOP 5', lbPanelX + lbPanelW / 2, lbPanelY + 22, lbTitleSize, '#FFD700');

        // Decorative line
        ctx.save();
        var lbLG = ctx.createLinearGradient(lbPanelX + 15, 0, lbPanelX + lbPanelW - 15, 0);
        lbLG.addColorStop(0, 'rgba(255, 215, 0, 0)');
        lbLG.addColorStop(0.5, 'rgba(255, 215, 0, 0.35)');
        lbLG.addColorStop(1, 'rgba(255, 215, 0, 0)');
        ctx.strokeStyle = lbLG;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(lbPanelX + 15, lbPanelY + 34);
        ctx.lineTo(lbPanelX + lbPanelW - 15, lbPanelY + 34);
        ctx.stroke();
        ctx.restore();

        // Entries (top 5)
        var lbEntrySize = Math.min(13, cw * 0.012);
        var lbEntryH = Math.min(26, (lbPanelH - 50) / 5);
        var showCount = Math.min(5, menuBoard.length);
        for (var lbi = 0; lbi < showCount; lbi++) {
            var lbEY = lbPanelY + 48 + lbi * lbEntryH;
            var lbRankCol, lbNameCol;
            if (lbi === 0) { lbRankCol = '#FFD700'; lbNameCol = '#FFD700'; }
            else if (lbi === 1) { lbRankCol = '#C0C0C0'; lbNameCol = '#C0C0C0'; }
            else if (lbi === 2) { lbRankCol = '#CD7F32'; lbNameCol = '#CD7F32'; }
            else { lbRankCol = '#777788'; lbNameCol = '#bbbbcc'; }

            ctx.save();
            ctx.font = 'bold ' + lbEntrySize + 'px "Segoe UI", Arial, sans-serif';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';
            ctx.fillStyle = lbRankCol;
            ctx.fillText((lbi + 1) + '.', lbPanelX + 12, lbEY);
            ctx.fillStyle = lbNameCol;
            ctx.fillText(menuBoard[lbi].name, lbPanelX + 35, lbEY);
            ctx.textAlign = 'right';
            ctx.fillText(menuBoard[lbi].score.toString(), lbPanelX + lbPanelW - 12, lbEY);
            ctx.restore();
        }
    }
}

function drawCountdown() {
    drawGame();

    // Overlay
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    var num = Math.ceil(countdownTimer / 0.8);
    if (num > 3) num = 3;
    if (num < 1) num = 1;
    var label = num === 0 ? 'GO!' : num.toString();
    var scale = 1 + (1 - ((countdownTimer % 0.8) / 0.8)) * 0.3;
    var col = num <= 1 ? '#44ff88' : '#ffaa44';
    drawNeonText(label, canvas.width / 2, canvas.height * 0.45, Math.floor(80 * scale), col);
}

function drawSetOver() {
    drawGame();

    // Dark overlay
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    var winner = p1Score > p2Score ? 'Player 1' : (isVsAI ? 'AI' : 'Player 2');
    var winnerColor = p1Score > p2Score ? '#44ff88' : '#ff44aa';

    drawNeonText('SET COMPLETE!', canvas.width / 2, canvas.height * 0.30, 44, '#ffaa00');
    drawNeonText(winner + ' wins the set!', canvas.width / 2, canvas.height * 0.42, 28, winnerColor);
    drawNeonText(p1Score + ' - ' + p2Score, canvas.width / 2, canvas.height * 0.52, 38, '#ffffff');
    drawNeonText('Sets: ' + p1Sets + ' - ' + p2Sets, canvas.width / 2, canvas.height * 0.62, 24, '#9999cc');

    // Pulsing continue text
    var alpha = 0.4 + Math.sin(Date.now() * 0.004) * 0.3;
    ctx.save();
    ctx.globalAlpha = alpha;
    drawNeonText('Press SPACE or ENTER to continue', canvas.width / 2, canvas.height * 0.75, 18, '#666699');
    ctx.restore();
}

function drawMatchOver() {
    drawGame();

    ctx.save();
    ctx.globalAlpha = 0.82;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    var cw = canvas.width;
    var ch = canvas.height;
    var winner = p1Sets > p2Sets ? 'Player 1' : (isVsAI ? 'AI' : 'Player 2');
    var winnerColor = p1Sets > p2Sets ? '#44ff88' : '#ff44aa';

    // Left side: match result
    var leftX = cw * 0.3;

    drawNeonText('MATCH OVER!', leftX, ch * 0.15, Math.min(48, cw * 0.04), '#ffaa00');

    ctx.save();
    ctx.shadowColor = winnerColor;
    ctx.shadowBlur = 30;
    drawNeonText(winner + ' WINS!', leftX, ch * 0.27, Math.min(36, cw * 0.032), winnerColor);
    ctx.restore();

    drawNeonText('Sets: ' + p1Sets + ' - ' + p2Sets, leftX, ch * 0.37, Math.min(28, cw * 0.025), '#ffffff');
    drawNeonText('Total Points: ' + matchWinnerScore, leftX, ch * 0.45, Math.min(22, cw * 0.02), '#aaaacc');

    // Trophy symbol
    ctx.save();
    ctx.font = Math.min(52, cw * 0.045) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#ffcc00';
    ctx.shadowBlur = 25;
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('\u{1F3C6}', leftX, ch * 0.56);
    ctx.restore();

    // Victory particles
    if (Math.random() < 0.15) {
        spawnParticles(
            cw * 0.2 + Math.random() * cw * 0.6,
            ch * 0.3 + Math.random() * ch * 0.4,
            winnerColor, 2, 4
        );
    }

    // Right side: leaderboard
    var rightX = cw * 0.72;
    drawLeaderboardPanel(rightX, ch * 0.1, Math.min(340, cw * 0.32), ch * 0.75, 10);

    // Continue prompt
    var alpha2 = 0.4 + Math.sin(Date.now() * 0.004) * 0.3;
    ctx.save();
    ctx.globalAlpha = alpha2;
    drawNeonText('Press SPACE or ENTER to continue', cw / 2, ch * 0.92, Math.min(18, cw * 0.016), '#666699');
    ctx.restore();
}

function drawLeaderboardPanel(cx, y, panelW, panelH, count) {
    var board = getLeaderboard();
    var cw = canvas.width;

    // Panel background
    var panelX = cx - panelW / 2;
    ctx.save();
    ctx.fillStyle = 'rgba(8, 8, 30, 0.85)';
    ctx.strokeStyle = 'rgba(100, 100, 200, 0.35)';
    ctx.lineWidth = 1.5;
    var cr = 10;
    ctx.beginPath();
    ctx.moveTo(panelX + cr, y);
    ctx.lineTo(panelX + panelW - cr, y);
    ctx.arcTo(panelX + panelW, y, panelX + panelW, y + cr, cr);
    ctx.lineTo(panelX + panelW, y + panelH - cr);
    ctx.arcTo(panelX + panelW, y + panelH, panelX + panelW - cr, y + panelH, cr);
    ctx.lineTo(panelX + cr, y + panelH);
    ctx.arcTo(panelX, y + panelH, panelX, y + panelH - cr, cr);
    ctx.lineTo(panelX, y + cr);
    ctx.arcTo(panelX, y, panelX + cr, y, cr);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // Title
    var titleSize = Math.min(22, cw * 0.02);
    drawNeonText('LEADERBOARD', cx, y + 28, titleSize, '#FFD700');

    // Decorative line under title
    ctx.save();
    var lg = ctx.createLinearGradient(panelX + 20, 0, panelX + panelW - 20, 0);
    lg.addColorStop(0, 'rgba(255, 215, 0, 0)');
    lg.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
    lg.addColorStop(1, 'rgba(255, 215, 0, 0)');
    ctx.strokeStyle = lg;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(panelX + 20, y + 42);
    ctx.lineTo(panelX + panelW - 20, y + 42);
    ctx.stroke();
    ctx.restore();

    // Column headers
    var headerY = y + 60;
    var fontSize = Math.min(14, cw * 0.013);
    ctx.save();
    ctx.font = 'bold ' + fontSize + 'px "Segoe UI", Arial, sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#7777aa';
    ctx.textAlign = 'left';
    ctx.fillText('#', panelX + 15, headerY);
    ctx.fillText('NAME', panelX + 45, headerY);
    ctx.textAlign = 'right';
    ctx.fillText('SCORE', panelX + panelW - 15, headerY);
    ctx.restore();

    // Entries
    var entryH = Math.min(30, (panelH - 80) / count);
    var entryFontSize = Math.min(15, cw * 0.014);
    for (var i = 0; i < count; i++) {
        var ey = headerY + 20 + i * entryH;
        var rankColor, nameColor;

        if (i === 0) { rankColor = '#FFD700'; nameColor = '#FFD700'; }       // Gold
        else if (i === 1) { rankColor = '#C0C0C0'; nameColor = '#C0C0C0'; }  // Silver
        else if (i === 2) { rankColor = '#CD7F32'; nameColor = '#CD7F32'; }   // Bronze
        else { rankColor = '#888899'; nameColor = '#ccccdd'; }

        ctx.save();
        ctx.font = 'bold ' + entryFontSize + 'px "Segoe UI", Arial, sans-serif';
        ctx.textBaseline = 'middle';

        if (i < board.length) {
            // Rank
            ctx.textAlign = 'left';
            ctx.fillStyle = rankColor;
            ctx.fillText((i + 1) + '.', panelX + 15, ey);
            // Name
            ctx.fillStyle = nameColor;
            ctx.fillText(board[i].name, panelX + 45, ey);
            // Score
            ctx.textAlign = 'right';
            ctx.fillStyle = nameColor;
            ctx.fillText(board[i].score.toString(), panelX + panelW - 15, ey);
        } else {
            // Empty slot
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333355';
            ctx.fillText((i + 1) + '.', panelX + 15, ey);
            ctx.fillText('---', panelX + 45, ey);
            ctx.textAlign = 'right';
            ctx.fillText('-', panelX + panelW - 15, ey);
        }
        ctx.restore();
    }
}

function drawNameEntry() {
    drawGame();

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    var cw = canvas.width;
    var ch = canvas.height;

    // Congratulations
    drawNeonText('NEW HIGH SCORE!', cw / 2, ch * 0.2, Math.min(44, cw * 0.04), '#FFD700');
    drawNeonText('Score: ' + matchWinnerScore, cw / 2, ch * 0.3, Math.min(30, cw * 0.028), '#ffffff');

    // Name entry prompt
    drawNeonText('ENTER YOUR NAME:', cw / 2, ch * 0.42, Math.min(24, cw * 0.022), '#aaaacc');

    // Name input box
    var boxW = Math.min(360, cw * 0.35);
    var boxH = Math.min(50, ch * 0.06);
    var boxX = cw / 2 - boxW / 2;
    var boxY = ch * 0.48;

    ctx.save();
    ctx.fillStyle = 'rgba(15, 15, 40, 0.9)';
    ctx.strokeStyle = '#44ccff';
    ctx.shadowColor = '#44ccff';
    ctx.shadowBlur = 8;
    ctx.lineWidth = 2;
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    ctx.restore();

    // Typed text
    var displayText = nameEntryText;
    nameEntryCursorBlink += 0.06;
    var showCursor = Math.sin(nameEntryCursorBlink * 3) > 0;
    if (showCursor) displayText += '_';

    var textSize = Math.min(28, cw * 0.026);
    ctx.save();
    ctx.font = 'bold ' + textSize + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#44ffcc';
    ctx.shadowColor = '#44ffcc';
    ctx.shadowBlur = 6;
    ctx.fillText(displayText, cw / 2, boxY + boxH / 2);
    ctx.restore();

    // Instructions
    var alpha3 = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
    ctx.save();
    ctx.globalAlpha = alpha3;
    drawNeonText('Type your name and press ENTER to confirm', cw / 2, ch * 0.62, Math.min(16, cw * 0.015), '#666699');
    ctx.restore();

    ctx.save();
    ctx.fillStyle = '#444466';
    ctx.font = Math.min(13, cw * 0.012) + 'px "Segoe UI", Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Max 12 characters  |  Letters, numbers, spaces', cw / 2, ch * 0.67);
    ctx.restore();
}

function drawPaused() {
    drawGame();

    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    drawNeonText('PAUSED', canvas.width / 2, canvas.height * 0.43, 52, '#ffaa00');

    var cx = canvas.width / 2;
    var btnW = 260, btnH = 50;
    var resumeY = canvas.height * 0.52;
    ctx.fillStyle = '#4a4';
    ctx.fillRect(cx - btnW/2, resumeY, btnW, btnH);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('RESUME', cx, resumeY + 33);

    var menuBtnY = resumeY + 70;
    ctx.fillStyle = '#c44';
    ctx.fillRect(cx - btnW/2, menuBtnY, btnW, btnH);
    ctx.fillStyle = '#fff';
    ctx.fillText('MAIN MENU', cx, menuBtnY + 33);

    ctx.font = '16px monospace';
    ctx.fillStyle = '#888';
    ctx.fillText('Press P to resume | ESC for main menu', cx, menuBtnY + 90);
    ctx.textAlign = 'left';

    pauseResumeBtn = { x: cx - btnW/2, y: resumeY, w: btnW, h: btnH };
    pauseMenuBtn = { x: cx - btnW/2, y: menuBtnY, w: btnW, h: btnH };
}

// --- Main Loop ---
function gameLoop(timestamp) {
    var dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    update(dt);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch(gameState) {
        case STATE.MENU:
            drawMenu();
            backLink.style.display = 'block';
            break;
        case STATE.COUNTDOWN:
            drawCountdown();
            backLink.style.display = 'none';
            break;
        case STATE.PLAYING:
            drawGame();
            backLink.style.display = 'none';
            break;
        case STATE.SET_OVER:
            drawSetOver();
            break;
        case STATE.MATCH_OVER:
            drawMatchOver();
            // Keep spawning victory particles
            updateParticles(dt);
            break;
        case STATE.NAME_ENTRY:
            drawNameEntry();
            backLink.style.display = 'none';
            break;
        case STATE.PAUSED:
            drawPaused();
            break;
    }

    requestAnimationFrame(gameLoop);
}

canvas.addEventListener('click', function(e) {
    if (gameState === STATE.PAUSED) {
        var rect = canvas.getBoundingClientRect();
        var mx = e.clientX - rect.left;
        var my = e.clientY - rect.top;
        if (pauseResumeBtn && mx >= pauseResumeBtn.x && mx <= pauseResumeBtn.x + pauseResumeBtn.w && my >= pauseResumeBtn.y && my <= pauseResumeBtn.y + pauseResumeBtn.h) {
            gameState = stateBeforePause || STATE.PLAYING;
        } else if (pauseMenuBtn && mx >= pauseMenuBtn.x && mx <= pauseMenuBtn.x + pauseMenuBtn.w && my >= pauseMenuBtn.y && my <= pauseMenuBtn.y + pauseMenuBtn.h) {
            window.location.href = '../../index.html';
        }
    }
});

lastTime = performance.now();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
